<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2025 Kia K4 GT-Line | Aurora Black Pearl</title>

  <!--
    DEPLOYMENT CHECKLIST:
    1. Upload THIS FILE to GitHub repo as kia-showcasev2.html
    2. Upload kiak4.glb to the SAME repo root
    3. The GLB URL below is absolute — works from any domain including Squarespace
    4. Squarespace iframe: src="https://aryaa207.github.io/Kiak4/kia-showcasev2.html"
  -->

  <script type="importmap">
  {
    "imports": {
      "three":         "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    *, *::before, *::after { box-sizing:border-box; margin:0; padding:0; }
    :root { --accent:#60b8ff; --accent2:#38d9ff; --bg:#06060f; --muted:rgba(255,255,255,0.35); }

    html, body { width:100%; height:100%; background:var(--bg); overflow:hidden; font-family:'Rajdhani',sans-serif; }
    #canvas-container { position:fixed; inset:0; }
    canvas { display:block; width:100%!important; height:100%!important; }

    /* ── Loader ── */
    #loader {
      position:fixed; inset:0; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:20px; z-index:100; transition:opacity 0.8s ease;
    }
    #loader.hidden { opacity:0; pointer-events:none; }
    #loader-status { font-family:'Orbitron',monospace; font-size:clamp(10px,2vw,13px); letter-spacing:.2em; color:var(--muted); margin-top:8px; max-width:80vw; text-align:center; }
    .loader-title { font-family:'Orbitron',monospace; font-size:clamp(13px,2.5vw,18px); letter-spacing:.35em; color:var(--accent); text-shadow:0 0 20px #60b8ff88; }
    .loader-bar-wrap { width:220px; height:2px; background:rgba(255,255,255,0.08); border-radius:2px; overflow:hidden; }
    .loader-bar { height:100%; background:linear-gradient(90deg,var(--accent),var(--accent2)); width:0%; transition:width 0.3s ease; box-shadow:0 0 10px var(--accent); }
    .loader-pct { font-family:'Orbitron',monospace; font-size:11px; letter-spacing:.2em; color:var(--muted); }

    /* ── Top UI ── */
    .ui-top { position:fixed; top:0; left:0; right:0; padding:24px 32px; display:flex; align-items:flex-start; justify-content:space-between; pointer-events:none; background:linear-gradient(to bottom,rgba(6,6,15,0.85) 0%,transparent 100%); }
    .brand { display:flex; flex-direction:column; gap:4px; }
    .brand-name { font-family:'Orbitron',monospace; font-size:clamp(14px,2.5vw,22px); font-weight:900; letter-spacing:.25em; color:#fff; text-shadow:0 0 40px rgba(96,184,255,0.3); }
    .brand-sub  { font-family:'Orbitron',monospace; font-size:clamp(8px,1.2vw,10px); letter-spacing:.5em; color:var(--accent); opacity:0.8; }
    .ui-stats { display:flex; flex-direction:column; align-items:flex-end; gap:3px; }
    .stat-row { font-family:'Orbitron',monospace; font-size:9px; letter-spacing:.15em; color:var(--muted); }
    .stat-val { color:var(--accent); }

    /* ── Speed panel ── */
    .speed-panel { position:fixed; bottom:0; left:0; right:0; padding:20px 24px 28px; background:linear-gradient(to top,rgba(6,6,15,0.95) 0%,transparent 100%); display:flex; flex-direction:column; align-items:center; gap:12px; }
    .speed-label { font-family:'Orbitron',monospace; font-size:11px; letter-spacing:.25em; color:var(--muted); display:flex; align-items:center; gap:10px; }
    .speed-mph   { color:#fff; font-size:20px; font-weight:600; text-shadow:0 0 16px var(--accent); min-width:40px; text-align:right; }
    .speed-presets { display:flex; gap:8px; }
    .preset-btn { background:transparent; border:1px solid rgba(255,255,255,0.12); color:rgba(255,255,255,0.5); border-radius:4px; padding:5px 14px; font-family:'Orbitron',monospace; font-size:10px; letter-spacing:.15em; cursor:pointer; transition:all .2s; }
    .preset-btn:hover, .preset-btn.active { border-color:var(--accent); color:var(--accent); background:rgba(96,184,255,0.08); box-shadow:0 0 12px rgba(96,184,255,0.15); }
    .speed-slider { width:min(280px,80vw); -webkit-appearance:none; appearance:none; height:2px; background:rgba(255,255,255,0.1); border-radius:2px; outline:none; cursor:pointer; }
    .speed-slider::-webkit-slider-thumb { -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); box-shadow:0 0 10px var(--accent),0 0 20px rgba(96,184,255,0.4); cursor:pointer; transition:transform .15s; }
    .speed-slider::-webkit-slider-thumb:hover { transform:scale(1.3); }

    /* ── Decor ── */
    .hint { position:fixed; bottom:130px; right:24px; font-family:'Rajdhani',sans-serif; font-size:11px; letter-spacing:.1em; color:var(--muted); text-align:right; line-height:1.8; pointer-events:none; }
    .vignette { position:fixed; inset:0; background:radial-gradient(ellipse at center,transparent 45%,rgba(6,6,15,0.65) 100%); pointer-events:none; }
    .corner { position:fixed; width:40px; height:40px; }
    .corner-tl { top:16px;    left:16px;   border-top:1px solid rgba(96,184,255,0.3); border-left:1px solid rgba(96,184,255,0.3); }
    .corner-tr { top:16px;    right:16px;  border-top:1px solid rgba(96,184,255,0.3); border-right:1px solid rgba(96,184,255,0.3); }
    .corner-bl { bottom:90px; left:16px;   border-bottom:1px solid rgba(96,184,255,0.3); border-left:1px solid rgba(96,184,255,0.3); }
    .corner-br { bottom:90px; right:16px;  border-bottom:1px solid rgba(96,184,255,0.3); border-right:1px solid rgba(96,184,255,0.3); }
    @media (max-width:480px) { .ui-stats,.hint { display:none; } }
  </style>
</head>
<body>

<div id="loader">
  <div class="loader-title">LOADING K4 GT-LINE</div>
  <div class="loader-bar-wrap"><div class="loader-bar" id="loader-bar"></div></div>
  <div class="loader-pct" id="loader-pct">0%</div>
  <div id="loader-status">Initialising…</div>
</div>

<div id="canvas-container"></div>
<div class="corner corner-tl"></div><div class="corner corner-tr"></div>
<div class="corner corner-bl"></div><div class="corner corner-br"></div>
<div class="vignette"></div>

<div class="ui-top">
  <div class="brand">
    <div class="brand-name">KIA K4 GT-LINE</div>
    <div class="brand-sub">AURORA BLACK PEARL · 2025</div>
  </div>
  <div class="ui-stats">
    <div class="stat-row">ENGINE &nbsp;<span class="stat-val">2.0L NATURALLY ASPIRATED</span></div>
    <div class="stat-row">OUTPUT &nbsp;<span class="stat-val">147 HP · 132 LB-FT</span></div>
    <div class="stat-row">DRIVE &nbsp;<span class="stat-val">FWD · CVT</span></div>
  </div>
</div>

<div class="hint">DRAG TO ROTATE<br/>SCROLL TO ZOOM</div>

<div class="speed-panel">
  <div class="speed-label">
    AIRFLOW SIMULATION &nbsp;·&nbsp;
    <span class="speed-mph" id="speed-display">40</span>&nbsp;MPH
  </div>
  <div class="speed-presets">
    <button class="preset-btn active" data-speed="40">40</button>
    <button class="preset-btn" data-speed="60">60</button>
    <button class="preset-btn" data-speed="80">80</button>
    <button class="preset-btn" data-speed="100">100</button>
  </div>
  <input type="range" class="speed-slider" id="speed-slider" min="40" max="100" step="1" value="40"/>
</div>

<script type="module">
import * as THREE        from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }    from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader }    from 'three/addons/loaders/RGBELoader.js';
import { DRACOLoader }   from 'three/addons/loaders/DRACOLoader.js';

// ─────────────────────────────────────────────────────────────────
// ABSOLUTE GLB URL  ← this is the key fix for Squarespace
// The file is served from GitHub Pages so any domain can load it.
// GitHub Pages sets permissive CORS headers on static assets.
// ─────────────────────────────────────────────────────────────────
const GLB_URL = 'https://aryaa207.github.io/Kiak4/kiak4.glb';

// ── Loader UI helpers ────────────────────────────────────────────
const loaderBar    = document.getElementById('loader-bar');
const loaderPct    = document.getElementById('loader-pct');
const loaderEl     = document.getElementById('loader');
const loaderStatus = document.getElementById('loader-status');

function setStatus(msg) { loaderStatus.textContent = msg; }
function hideLoader() {
  loaderEl.classList.add('hidden');
  setTimeout(() => loaderEl.style.display = 'none', 900);
}

// ── Speed state ──────────────────────────────────────────────────
let currentSpeed = 40;
const slider       = document.getElementById('speed-slider');
const speedDisplay = document.getElementById('speed-display');
const presetBtns   = document.querySelectorAll('.preset-btn');
function setSpeed(v) {
  currentSpeed = v; slider.value = v; speedDisplay.textContent = v;
  presetBtns.forEach(b => b.classList.toggle('active', +b.dataset.speed === v));
}
slider.addEventListener('input', () => setSpeed(+slider.value));
presetBtns.forEach(b => b.addEventListener('click', () => setSpeed(+b.dataset.speed)));

// ── Renderer ─────────────────────────────────────────────────────
// alpha:false + explicit setClearColor prevents the black-rectangle
// artifact caused by framebuffer alpha=0 patches.
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled   = true;
renderer.shadowMap.type      = THREE.PCFSoftShadowMap;
renderer.toneMapping         = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.3;
renderer.outputColorSpace    = THREE.SRGBColorSpace;
renderer.setClearColor(0x06060f, 1.0);  // matches scene.background — no alpha gap
document.getElementById('canvas-container').appendChild(renderer.domElement);

// ── Scene ────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06060f);
scene.fog = new THREE.FogExp2(0x06060f, 0.035);

// ── Camera ───────────────────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(5, 2, 5);

// ── Controls ─────────────────────────────────────────────────────
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan      = false;
controls.minDistance    = 3;
controls.maxDistance    = 14;
controls.minPolarAngle  = 0.1;
controls.maxPolarAngle  = Math.PI / 2.05;
controls.autoRotate     = true;
controls.autoRotateSpeed = 0.4;
controls.enableDamping  = true;
controls.dampingFactor  = 0.06;

// ── Lighting ─────────────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.18));

const sun = new THREE.DirectionalLight(0xffffff, 1.6);
sun.position.set(5, 8, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5; sun.shadow.camera.far  = 25;
sun.shadow.camera.left = sun.shadow.camera.bottom = -6;
sun.shadow.camera.right = sun.shadow.camera.top   =  6;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x4488ff, 0.6);
fill.position.set(-5, 3, -4); scene.add(fill);

const rim = new THREE.DirectionalLight(0x88ccff, 0.4);
rim.position.set(0, 2, -6); scene.add(rim);

// ── HDRI environment ─────────────────────────────────────────────
setStatus('Loading studio environment…');
const rgbeLoader = new RGBELoader();
rgbeLoader.load(
  'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr',
  (hdr) => {
    hdr.mapping    = THREE.EquirectangularReflectionMapping;
    hdr.minFilter  = THREE.LinearFilter;
    hdr.magFilter  = THREE.LinearFilter;
    scene.environment = hdr;
    setStatus('Loading car model…');
    loadCar();
  },
  undefined,
  () => {
    // Fallback to synthetic env if HDRI blocked
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envTex = pmrem.fromScene(new THREE.RoomEnvironment()).texture;
    envTex.minFilter = THREE.LinearFilter;
    envTex.magFilter = THREE.LinearFilter;
    scene.environment = envTex;
    pmrem.dispose();
    setStatus('Loading car model…');
    loadCar();
  }
);

// ── Ground ───────────────────────────────────────────────────────
const shadowGround = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.ShadowMaterial({ opacity: 0.5 })
);
shadowGround.rotation.x = -Math.PI / 2;
shadowGround.position.y = -0.5;
shadowGround.receiveShadow = true;
scene.add(shadowGround);

const reflectFloor = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshStandardMaterial({ color: 0x0a0a14, metalness: 0.4, roughness: 0.6, envMapIntensity: 0.6 })
);
reflectFloor.rotation.x = -Math.PI / 2;
reflectFloor.position.y = -0.501;
scene.add(reflectFloor);

// ── Material presets ─────────────────────────────────────────────
const MAT_AURORA = new THREE.MeshStandardMaterial({
  color: 0x080810, metalness: 0.92, roughness: 0.07, envMapIntensity: 3.2,
});
const MAT_CHROME = new THREE.MeshStandardMaterial({
  color: 0xc0c8d0, metalness: 1.0, roughness: 0.04, envMapIntensity: 3.5,
});
const MAT_GLASS = new THREE.MeshPhysicalMaterial({
  color: 0x8ab8d8, metalness: 0, roughness: 0,
  transmission: 0.9, thickness: 0.4,
  transparent: true, opacity: 0.25, envMapIntensity: 1.5,
});
const MAT_RUBBER = new THREE.MeshStandardMaterial({
  color: 0x111111, metalness: 0, roughness: 0.95,
});

function isWhitish(mat) {
  if (!mat?.color) return false;
  const { r, g, b } = mat.color;
  return r > 0.72 && g > 0.72 && b > 0.72;
}

// ── Wheel mesh refs  (populated by loadCar → applyMaterials) ─────
// These are rotated every frame proportional to currentSpeed.
const wheelMeshes = [];

function applyMaterials(model) {
  model.traverse((node) => {
    if (!node.isMesh) return;
    node.castShadow = node.receiveShadow = true;
    const n   = node.name.toLowerCase();
    const mat = Array.isArray(node.material) ? node.material[0] : node.material;

    const isGlass  = ['glass','window','windshield','wind','screen','lens','light','lamp'].some(k => n.includes(k)) || isWhitish(mat);
    const isBody   = ['body','paint','panel','hood','door','fender','roof','trunk','bumper'].some(k => n.includes(k));
    const isChrome = ['chrome','trim','grille','exhaust','mirror','badge'].some(k => n.includes(k));
    const isWheel  = ['wheel','tire','tyre','rim','brake','disc','caliper'].some(k => n.includes(k));

    if      (isGlass)  { node.material = MAT_GLASS.clone();  node.renderOrder = 1; }
    else if (isBody)   { node.material = MAT_AURORA.clone(); }
    else if (isChrome) { node.material = MAT_CHROME.clone(); }
    else if (isWheel)  { node.material = MAT_RUBBER.clone(); }

    // ── WHEEL SPIN: collect refs here, rotate in animate() ──────
    if (isWheel) {
      wheelMeshes.push(node);
      console.log('[K4 Wheel found]', node.name);
    }
  });
}

// ── Car loader ───────────────────────────────────────────────────
function loadCar() {
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
  const loader = new GLTFLoader();
  loader.setDRACOLoader(draco);

  console.log('[K4] Fetching:', GLB_URL);
  setStatus('Fetching model from GitHub…');

  loader.load(
    GLB_URL,
    (gltf) => {
      console.log('[K4] ✓ Model loaded. Children:', gltf.scene.children.length);
      console.log('[K4] Wheel meshes found:', wheelMeshes.length);
      applyMaterials(gltf.scene);
      gltf.scene.position.set(0, -0.5, 0);
      gltf.scene.scale.set(1, 1, 1);
      scene.add(gltf.scene);
      // ↓ MUST be called after scene.add so raycasts hit the car geometry
      buildSmokeWands(gltf.scene);
      hideLoader();
    },
    (xhr) => {
      if (xhr.lengthComputable) {
        const p = Math.round(xhr.loaded / xhr.total * 100);
        loaderBar.style.width = p + '%';
        loaderPct.textContent = p + '%';
        setStatus(`Downloading model… ${p}%`);
      }
    },
    (err) => {
      console.error('[K4] ✗ Load failed:', err);
      loaderPct.textContent = '⚠ MODEL FAILED TO LOAD';
      loaderBar.style.background = '#f87171';
      setStatus('Check browser console (F12) for details. Ensure kiak4.glb is in the GitHub repo root.');
    }
  );
}

// ─────────────────────────────────────────────────────────────────
// SMOKE WAND SYSTEM  v7  ─ Surface-Aware Raycaster Edition
//
// Key guarantees:
//   • Geometry built ONCE inside buildSmokeWands(), called only after
//     the GLB is fully in the scene so raycasts actually hit the car.
//   • uTime updated every frame — zero geometry recalculation.
//   • AdditiveBlending: can never write black, no compositor needed.
//   • All shader outputs clamped [0,1] — NaN/Inf impossible.
// ─────────────────────────────────────────────────────────────────

// ── Cinematic shader ─────────────────────────────────────────────
// Combines the pulse-wave animation from the user's SmokeMaterial
// with our proven head/tail fade and radial-taper logic.
const smokeVert = `
  varying vec2 vUv;
  void main() {
    vUv         = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const smokeFrag = `
  uniform float uTime;
  uniform float uSpeed;   // maps to mph → controls pulse frequency
  uniform vec3  uColor;
  uniform float uOpacity;
  varying vec2  vUv;

  void main() {
    // ── Travelling pulse ─────────────────────────────────────────
    // Speed-linked: faster MPH = faster pulse wave
    float pulse = sin(vUv.x * 9.0 - uTime * uSpeed * 2.8) * 0.42 + 0.58;

    // ── Edge fade: smooth head and tail ──────────────────────────
    float edgeFade = smoothstep(0.0, 0.08, vUv.x) * smoothstep(1.0, 0.72, vUv.x);

    // ── Radial taper: bright core, soft edge ─────────────────────
    float radial = sin(clamp(vUv.y, 0.0, 1.0) * 3.14159265);
    float core   = pow(clamp(radial, 0.0, 1.0), 1.5);

    // ── Bright leading tip ────────────────────────────────────────
    float tip = pow(clamp(1.0 - vUv.x / 0.06, 0.0, 1.0), 3.0);

    float alpha = clamp((pulse * edgeFade + tip * 0.6) * core * uOpacity, 0.0, 1.0);
    if (alpha < 0.005) discard;

    // Tip brightens to near-white for visual pop
    vec3 col = clamp(
      mix(uColor, vec3(0.90, 0.98, 1.00), tip * core * 0.6) * 1.4,
      0.0, 1.0
    );
    gl_FragColor = vec4(col * alpha, alpha);
  }
`;

// ── Surface-detection raycaster ──────────────────────────────────
// Fires a downward ray at each Z slice and lands 5 cm above whatever
// it hits (car roof, hood, windshield, trunk).  Falls back to the
// freestream Y if nothing is below (open air before/after the car).
const SURFACE_OFFSET = 0.05;  // 5 cm clearance above paint

function getSurfaceAdjustedPoints(startX, freeY, carModel) {
  const raycaster  = new THREE.Raycaster();
  const downVector = new THREE.Vector3(0, -1, 0);
  const segments   = 60;
  const totalLen   = 14;      // front of tunnel → rear wake
  const pts        = [];
  let prevY        = freeY;   // tracks last known Y for smooth falloff recovery

  for (let i = 0; i < segments; i++) {
    const t  = i / (segments - 1);
    const pz = 7 - t * totalLen;   // +7 (front) → -7 (wake)
    const px = startX;

    // Cast from 4 units above — safely above any car geometry
    raycaster.set(new THREE.Vector3(px, 4, pz), downVector);
    const hits = raycaster.intersectObject(carModel, true);

    let py;
    if (hits.length > 0) {
      // Landed on car surface — ride 5 cm above impact point
      py = hits[0].point.y + SURFACE_OFFSET;
    } else {
      // No car below — gradually recover toward freestream height
      // prevY keeps continuity so there's no sudden jump off the tail
      py = prevY + (freeY - prevY) * 0.12;
    }
    prevY = py;

    // Lateral splay over wheel arches (same physics as before)
    let px2 = px;
    if (Math.abs(px) > 0.55 && pz > -3.3 && pz < 3.3) {
      const arch = 0.10 * Math.max(0, Math.sin((3.3 - Math.abs(pz)) / 3.3 * Math.PI));
      px2 = px > 0 ? px + arch : px - arch;
    }

    pts.push(new THREE.Vector3(px2, py, pz));
  }

  return pts;
}

// ── Wand seed definitions ─────────────────────────────────────────
// 12 wands evenly spread across car width, per spec.
// x  = lateral position (-1.2 → +1.2)
// y  = freestream height if no surface hit (approaches from here)
// r  = tube radius (0.04 per spec, slightly varied for depth)
// op = opacity
// spd = per-wand pulse speed multiplier for organic variation
const WAND_SEEDS = [
  // Centre (x=0) — boldest ribbon
  { x:  0.00, y: 0.55, r: 0.048, op: 0.72, spd: 0.88 },

  // ±0.24 — inner A-pillar
  { x: -0.24, y: 0.50, r: 0.042, op: 0.64, spd: 0.95 },
  { x:  0.24, y: 0.50, r: 0.042, op: 0.64, spd: 0.82 },

  // ±0.52 — door shoulder
  { x: -0.52, y: 0.45, r: 0.040, op: 0.58, spd: 1.02 },
  { x:  0.52, y: 0.45, r: 0.040, op: 0.58, spd: 0.76 },

  // ±0.78 — mirror / fender crest
  { x: -0.78, y: 0.40, r: 0.036, op: 0.50, spd: 1.10 },
  { x:  0.78, y: 0.40, r: 0.036, op: 0.50, spd: 0.68 },

  // ±1.00 — fender edge
  { x: -1.00, y: 0.35, r: 0.030, op: 0.42, spd: 0.90 },
  { x:  1.00, y: 0.35, r: 0.030, op: 0.42, spd: 1.06 },

  // ±1.20 — outermost, per spec (-1.2 → 1.2)
  { x: -1.20, y: 0.30, r: 0.024, op: 0.34, spd: 1.14 },
  { x:  1.20, y: 0.30, r: 0.024, op: 0.34, spd: 0.72 },

  // High free-stream above roof — always visible
  { x:  0.00, y: 1.20, r: 0.028, op: 0.38, spd: 0.94 },
];

// ── smokeWands array (filled by buildSmokeWands after GLB loads) ──
const smokeWands = [];

// ── buildSmokeWands(carModel) ─────────────────────────────────────
// Called ONCE after gltf.scene is in the scene graph so raycasts hit.
// Builds TubeGeometry for each seed using the raycaster-derived path,
// then adds the mesh to the scene.  Never called again — only uTime
// is updated per frame.
function buildSmokeWands(carModel) {
  console.log('[K4] Building surface-aware smoke wands…');

  WAND_SEEDS.forEach((seed, i) => {
    // 1. Get the raycasted path — this is the expensive part, done once
    const pts   = getSurfaceAdjustedPoints(seed.x, seed.y, carModel);
    const curve = new THREE.CatmullRomCurve3(pts);

    // 2. Build TubeGeometry once
    const geo = new THREE.TubeGeometry(
      curve,
      80,       // tubular segments — smooth curves
      seed.r,   // radius (0.04 per spec, varied slightly)
      8,        // radial segments
      false     // not closed
    );
    geo.computeBoundingSphere();

    // 3. Cinematic shader material — only uTime updated per frame
    const mat = new THREE.ShaderMaterial({
      vertexShader:   smokeVert,
      fragmentShader: smokeFrag,
      uniforms: {
        uTime:    { value: 0.0 },
        uSpeed:   { value: 1.0 },   // set from currentSpeed each frame
        uColor:   { value: new THREE.Color(0x38d8ff) },
        uOpacity: { value: seed.op },
      },
      transparent: true,
      depthWrite:  false,
      blending:    THREE.AdditiveBlending,
      side:        THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geo, mat);
    mesh.renderOrder   = 2;
    mesh.frustumCulled = true;
    scene.add(mesh);

    // Store reference — phase offset staggers the pulse wave per wand
    smokeWands.push({
      mat,
      phaseOffset: (i / WAND_SEEDS.length) * Math.PI * 2,
      spd: seed.spd,
    });
  });

  console.log(`[K4] ✓ ${smokeWands.length} surface-aware wands built`);
}

// ─────────────────────────────────────────────────────────────────
// ANIMATION LOOP
// ─────────────────────────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta   = clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // ── Smoke animation ──────────────────────────────────────────────
  // Geometry is static — only uTime and uSpeed uniforms update each frame.
  // uSpeed is normalised so 40 mph = slow pulse, 100 mph = fast pulse.
  const normalizedSpeed = 0.4 + ((currentSpeed - 40) / 60) * 1.2; // 0.4–1.6 range
  for (const { mat, phaseOffset, spd } of smokeWands) {
    mat.uniforms.uTime.value  = elapsed + phaseOffset;
    mat.uniforms.uSpeed.value = normalizedSpeed * spd;
  }

  // ── WHEEL SPIN ───────────────────────────────────────────────
  // Physics: rad/s = linear_speed_m_s / wheel_radius_m
  // 40 mph = 17.88 m/s → at r=0.33m → 54.2 rad/s real
  // Visual scale factor 0.010 keeps it looking right in scene units
  // Multiply by delta (seconds since last frame) for frame-rate independence
  const wheelRadPerSec = (currentSpeed * 0.44704 / 0.33) * 0.010;
  for (const m of wheelMeshes) {
    m.rotation.x -= wheelRadPerSec * delta;
  }

  controls.update();
  renderer.render(scene, camera);  // single direct render — no composer, no artifacts
}
animate();

// ── Resize ───────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
