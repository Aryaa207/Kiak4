<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2025 Kia K4 GT-Line | Aurora Black Pearl</title>

  <!-- Three.js + addons from CDN – no installation needed -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --accent: #60b8ff;
      --accent2: #38d9ff;
      --bg: #06060f;
      --text: #e2e8f0;
      --muted: rgba(255,255,255,0.35);
    }

    html, body {
      width: 100%; height: 100%;
      background: var(--bg);
      overflow: hidden;
      font-family: 'Rajdhani', sans-serif;
    }

    /* ── Canvas ── */
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    canvas { display: block; width: 100% !important; height: 100% !important; }

    /* ── Loading screen ── */
    #loader {
      position: fixed; inset: 0;
      background: var(--bg);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 20px; z-index: 100;
      transition: opacity 0.8s ease;
    }
    #loader.hidden { opacity: 0; pointer-events: none; }

    .loader-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(13px, 2.5vw, 18px);
      letter-spacing: .35em;
      color: var(--accent);
      text-shadow: 0 0 20px #60b8ff88;
    }
    .loader-bar-wrap {
      width: 220px; height: 2px;
      background: rgba(255,255,255,0.08);
      border-radius: 2px; overflow: hidden;
    }
    .loader-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px var(--accent);
    }
    .loader-pct {
      font-family: 'Orbitron', monospace;
      font-size: 11px; letter-spacing: .2em;
      color: var(--muted);
    }

    /* ── UI Chrome ── */
    .ui-top {
      position: fixed; top: 0; left: 0; right: 0;
      padding: 24px 32px;
      display: flex; align-items: flex-start; justify-content: space-between;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(6,6,15,0.8) 0%, transparent 100%);
    }

    .brand {
      display: flex; flex-direction: column; gap: 4px;
    }
    .brand-name {
      font-family: 'Orbitron', monospace;
      font-size: clamp(14px, 2.5vw, 22px);
      font-weight: 900;
      letter-spacing: .25em;
      color: #fff;
      text-shadow: 0 0 40px rgba(96,184,255,0.3);
    }
    .brand-sub {
      font-family: 'Orbitron', monospace;
      font-size: clamp(8px, 1.2vw, 10px);
      letter-spacing: .5em;
      color: var(--accent);
      opacity: 0.8;
    }

    .ui-stats {
      display: flex; flex-direction: column; align-items: flex-end; gap: 3px;
    }
    .stat-row {
      font-family: 'Orbitron', monospace;
      font-size: 9px; letter-spacing: .15em;
      color: var(--muted);
    }
    .stat-val { color: var(--accent); }

    /* ── Speed Panel ── */
    .speed-panel {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 20px 24px 28px;
      background: linear-gradient(to top, rgba(6,6,15,0.95) 0%, transparent 100%);
      display: flex; flex-direction: column; align-items: center; gap: 12px;
    }

    .speed-label {
      font-family: 'Orbitron', monospace;
      font-size: 11px; letter-spacing: .25em;
      color: var(--muted);
      display: flex; align-items: center; gap: 10px;
    }
    .speed-mph {
      color: #fff; font-size: 20px; font-weight: 600;
      text-shadow: 0 0 16px var(--accent);
      min-width: 40px; text-align: right;
    }

    /* Preset buttons */
    .speed-presets {
      display: flex; gap: 8px;
    }
    .preset-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.5);
      border-radius: 4px;
      padding: 5px 14px;
      font-family: 'Orbitron', monospace;
      font-size: 10px; letter-spacing: .15em;
      cursor: pointer;
      transition: all .2s;
    }
    .preset-btn:hover,
    .preset-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(96,184,255,0.08);
      box-shadow: 0 0 12px rgba(96,184,255,0.15);
    }

    /* Slider */
    .speed-slider {
      width: min(280px, 80vw);
      -webkit-appearance: none;
      appearance: none;
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent), 0 0 20px rgba(96,184,255,0.4);
      cursor: pointer;
      transition: transform .15s;
    }
    .speed-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }

    /* Hint */
    .hint {
      position: fixed;
      bottom: 130px; right: 24px;
      font-family: 'Rajdhani', sans-serif;
      font-size: 11px; letter-spacing: .1em;
      color: var(--muted);
      text-align: right;
      line-height: 1.8;
      pointer-events: none;
    }

    /* Vignette */
    .vignette {
      position: fixed; inset: 0;
      background: radial-gradient(ellipse at center, transparent 45%, rgba(6,6,15,0.7) 100%);
      pointer-events: none;
    }

    /* Corner accent lines */
    .corner { position: fixed; width: 40px; height: 40px; }
    .corner-tl { top: 16px; left: 16px; border-top: 1px solid rgba(96,184,255,0.3); border-left: 1px solid rgba(96,184,255,0.3); }
    .corner-tr { top: 16px; right: 16px; border-top: 1px solid rgba(96,184,255,0.3); border-right: 1px solid rgba(96,184,255,0.3); }
    .corner-bl { bottom: 90px; left: 16px; border-bottom: 1px solid rgba(96,184,255,0.3); border-left: 1px solid rgba(96,184,255,0.3); }
    .corner-br { bottom: 90px; right: 16px; border-bottom: 1px solid rgba(96,184,255,0.3); border-right: 1px solid rgba(96,184,255,0.3); }

    @media (max-width: 480px) {
      .ui-stats { display: none; }
      .hint { display: none; }
    }
  </style>
</head>
<body>

<!-- Loading screen -->
<div id="loader">
  <div class="loader-title">LOADING K4 GT-LINE</div>
  <div class="loader-bar-wrap"><div class="loader-bar" id="loader-bar"></div></div>
  <div class="loader-pct" id="loader-pct">0%</div>
</div>

<!-- Three.js canvas -->
<div id="canvas-container"></div>

<!-- Decorative corners -->
<div class="corner corner-tl"></div>
<div class="corner corner-tr"></div>
<div class="corner corner-bl"></div>
<div class="corner corner-br"></div>

<!-- Vignette -->
<div class="vignette"></div>

<!-- Top UI -->
<div class="ui-top">
  <div class="brand">
    <div class="brand-name">KIA K4 GT-LINE</div>
    <div class="brand-sub">AURORA BLACK PEARL · 2025</div>
  </div>
  <div class="ui-stats">
    <div class="stat-row">ENGINE &nbsp;<span class="stat-val" id="stat-engine">2.0L NATURALLY ASPIRATED</span></div>
    <div class="stat-row">OUTPUT &nbsp;<span class="stat-val">147 HP · 132 LB-FT</span></div>
    <div class="stat-row">DRIVE &nbsp;<span class="stat-val">FWD · CVT</span></div>
  </div>
</div>

<!-- Drag hint -->
<div class="hint">
  DRAG TO ROTATE<br/>
  SCROLL TO ZOOM
</div>

<!-- Speed panel -->
<div class="speed-panel">
  <div class="speed-label">
    AIRFLOW SIMULATION &nbsp;·&nbsp;
    <span class="speed-mph" id="speed-display">40</span>
    &nbsp;MPH
  </div>
  <div class="speed-presets">
    <button class="preset-btn active" data-speed="40">40</button>
    <button class="preset-btn" data-speed="60">60</button>
    <button class="preset-btn" data-speed="80">80</button>
    <button class="preset-btn" data-speed="100">100</button>
  </div>
  <input type="range" class="speed-slider" id="speed-slider" min="40" max="100" step="1" value="40"/>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader }     from 'three/addons/loaders/RGBELoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';

// ─────────────────────────────────────────────
// SPEED STATE
// ─────────────────────────────────────────────
let currentSpeed = 40; // mph

const slider       = document.getElementById('speed-slider');
const speedDisplay = document.getElementById('speed-display');
const presetBtns   = document.querySelectorAll('.preset-btn');

function setSpeed(v) {
  currentSpeed = v;
  slider.value = v;
  speedDisplay.textContent = v;
  presetBtns.forEach(b => b.classList.toggle('active', +b.dataset.speed === v));
}

slider.addEventListener('input', () => setSpeed(+slider.value));
presetBtns.forEach(b => b.addEventListener('click', () => setSpeed(+b.dataset.speed)));

// ─────────────────────────────────────────────
// RENDERER
// ─────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.3;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

// ─────────────────────────────────────────────
// SCENE + CAMERA
// ─────────────────────────────────────────────
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0x06060f);
scene.fog = new THREE.FogExp2(0x06060f, 0.04);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(5, 2, 5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan     = false;
controls.minDistance   = 3;
controls.maxDistance   = 12;
controls.minPolarAngle = 0.15;
controls.maxPolarAngle = Math.PI / 2.1;
controls.autoRotate    = true;
controls.autoRotateSpeed = 0.5;
controls.enableDamping = true;
controls.dampingFactor = 0.06;

// ─────────────────────────────────────────────
// LIGHTING
// ─────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.15));

const sun = new THREE.DirectionalLight(0xffffff, 1.4);
sun.position.set(5, 8, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far  = 25;
sun.shadow.camera.left = sun.shadow.camera.bottom = -6;
sun.shadow.camera.right = sun.shadow.camera.top   =  6;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x4488ff, 0.5);
fill.position.set(-5, 3, -4);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.3);
rim.position.set(0, 2, -6);
scene.add(rim);

// ─────────────────────────────────────────────
// HDRI ENVIRONMENT  (studio-like sky for sharp reflections)
// Using a public domain HDRI from Poly Haven via CDN
// ─────────────────────────────────────────────
const rgbeLoader = new RGBELoader();
rgbeLoader.load(
  'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr',
  (hdr) => {
    hdr.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = hdr;  // used for reflections only (not background)
  },
  undefined,
  () => {
    // Fallback if network blocked – create a synthetic env map
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envScene = new THREE.RoomEnvironment();
    scene.environment = pmrem.fromScene(envScene).texture;
    pmrem.dispose();
  }
);

// ─────────────────────────────────────────────
// GROUND SHADOW PLANE
// ─────────────────────────────────────────────
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.ShadowMaterial({ opacity: 0.45 })
);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.5;
ground.receiveShadow = true;
scene.add(ground);

// Subtle reflective floor
const floorMat = new THREE.MeshStandardMaterial({
  color: 0x0a0a14,
  metalness: 0.4,
  roughness: 0.6,
  envMapIntensity: 0.5,
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y  = -0.501;
scene.add(floor);

// ─────────────────────────────────────────────
// LOAD GLB MODEL
// ─────────────────────────────────────────────
const loaderBar = document.getElementById('loader-bar');
const loaderPct = document.getElementById('loader-pct');
const loaderEl  = document.getElementById('loader');

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

// ── Material presets ──────────────────────────
const AURORA_BLACK = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x080810),
  metalness: 0.9,
  roughness: 0.08,
  envMapIntensity: 3.0,
});

const CHROME = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0xc0c8d0),
  metalness: 1.0,
  roughness: 0.04,
  envMapIntensity: 3.5,
});

const GLASS = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color(0x8ab8d8),
  metalness: 0.0,
  roughness: 0.0,
  transmission: 0.9,
  thickness: 0.4,
  transparent: true,
  opacity: 0.25,
  envMapIntensity: 1.5,
});

const RUBBER = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x111111),
  metalness: 0.0,
  roughness: 0.95,
});

function isWhitish(mat) {
  if (!mat || !mat.color) return false;
  const c = mat.color;
  return c.r > 0.72 && c.g > 0.72 && c.b > 0.72;
}

function applyMaterials(model) {
  model.traverse((node) => {
    if (!node.isMesh) return;
    node.castShadow    = true;
    node.receiveShadow = true;

    const n   = node.name.toLowerCase();
    const mat = Array.isArray(node.material) ? node.material[0] : node.material;

    const isGlassByName  = n.includes('glass') || n.includes('window') ||
                           n.includes('windshield') || n.includes('wind') ||
                           n.includes('screen') || n.includes('lens') ||
                           n.includes('light') || n.includes('lamp');
    const isGlassByColor = isWhitish(mat);

    if (isGlassByName || isGlassByColor) {
      node.material = GLASS.clone();
      node.renderOrder = 1;
    } else if (n.includes('body') || n.includes('paint') || n.includes('panel') ||
               n.includes('hood') || n.includes('door') || n.includes('fender') ||
               n.includes('roof') || n.includes('trunk') || n.includes('bumper')) {
      node.material = AURORA_BLACK.clone();
    } else if (n.includes('chrome') || n.includes('trim') || n.includes('grille') ||
               n.includes('exhaust') || n.includes('mirror')) {
      node.material = CHROME.clone();
    } else if (n.includes('tyre') || n.includes('tire') || n.includes('rubber') ||
               n.includes('wheel') || n.includes('rim')) {
      node.material = RUBBER.clone();
    }
  });
}

gltfLoader.load(
  './kiak4.glb',                  // relative to index.html
  (gltf) => {
    applyMaterials(gltf.scene);
    gltf.scene.position.y = -0.5;
    scene.add(gltf.scene);

    // Hide loader
    loaderEl.classList.add('hidden');
    setTimeout(() => loaderEl.style.display = 'none', 900);
  },
  (xhr) => {
    if (xhr.lengthComputable) {
      const pct = Math.round(xhr.loaded / xhr.total * 100);
      loaderBar.style.width = pct + '%';
      loaderPct.textContent  = pct + '%';
    }
  },
  (err) => {
    console.error('GLB load error:', err);
    loaderPct.textContent = 'MODEL NOT FOUND – place kiak4.glb next to index.html';
    loaderBar.style.background = '#f87171';
  }
);


// ═══════════════════════════════════════════════════════════════════
// SMOKE WAND SYSTEM  –  cinematic, car-visible version
//
// Key changes vs previous:
//  • Bloom threshold 0.85, strength 0.55  → only tube tips glow,
//    black paint stays black
//  • NormalBlending instead of AdditiveBlending → no stacking/blowout
//  • Opacity 0.22–0.38  → you can see the car through the smoke
//  • Tube radius 0.022 max → distinct ribbons, not a fog wall
//  • GLSL fade: tail alpha goes to exactly 0.0, no white fog buildup
//  • 0.02 unit surface clearance → zero Z-fighting
// ═══════════════════════════════════════════════════════════════════

// ── 1. Post-processing: restrained Bloom ─────────────────────────
import { EffectComposer }  from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass }      from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass }      from 'three/addons/postprocessing/OutputPass.js';

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.55,  // strength  – was 1.4, now subtle
  0.40,  // radius    – tight halo
  0.85   // threshold – only the brightest tube tips bloom;
         //             the black car paint is completely untouched
);
composer.addPass(bloomPass);
composer.addPass(new OutputPass());

// ── 2. GLSL shader – hard fade, zero fog buildup ─────────────────
const smokeVert = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const smokeFrag = `
  uniform vec3  uColor;
  uniform float uTime;
  uniform float uOpacity;
  uniform float uHead;    // animated head position 0 to 1

  varying vec2 vUv;

  void main() {

    // ── Tail fade ─────────────────────────────────────────────────
    // Measure how far behind the head this fragment sits.
    // behind=0  →  at the head tip (full brightness)
    // behind=tailLen → tail end (alpha 0)
    float tailLen = 0.68;

    float behind = uHead - vUv.x;
    if (behind < 0.0) behind += 1.0;

    if (behind > tailLen) discard;  // hard cut – no ghost fog

    // Smooth linear fade from head to tail
    float alongAlpha = 1.0 - (behind / tailLen);
    // Slightly ease the very tip to avoid a hard front edge
    alongAlpha *= smoothstep(0.0, 0.03, behind + 0.001);
    // Sharp leading edge glint
    float tip = 1.0 - smoothstep(0.0, 0.05, behind);

    // ── Radial fade ───────────────────────────────────────────────
    float radial = sin(vUv.y * 3.14159265);
    float core   = pow(radial, 2.2);  // tighter core than before

    // ── Combine ───────────────────────────────────────────────────
    float alpha = alongAlpha * core * uOpacity;
    alpha      += tip * core * uOpacity * 0.6;

    if (alpha < 0.008) discard;

    // Tip colour boost so bloom has something to catch
    vec3 col = mix(uColor, vec3(0.88, 0.97, 1.00), tip * core * 0.65);

    gl_FragColor = vec4(col, alpha);
  }
`;

// ── 3. Car body silhouette ────────────────────────────────────────
const CLEARANCE = 0.02;  // prevents Z-fighting

function carTopY(pz) {
  if (pz >  3.3 || pz < -3.6) return -99;
  let y;
  if      (pz >  2.5) y = -0.15 + (3.3 - pz) / 0.8  * 0.28;
  else if (pz >  0.5) y =  0.13 + (2.5 - pz) / 2.0  * 0.68;
  else if (pz > -0.5) y =  0.81 + Math.sin((pz + 0.5) / 1.0 * Math.PI) * 0.05;
  else if (pz > -3.1) y =  0.81 - (-0.5 - pz) / 2.6  * 0.83;
  else                y = -0.02;
  return y + CLEARANCE;
}

// ── 4. Path builder ───────────────────────────────────────────────
function buildWandPath(seedX, seedY, nPts = 80) {
  const pts = [];
  for (let i = 0; i < nPts; i++) {
    const t  = i / (nPts - 1);
    const pz = 7.0 - t * 13.0;

    let x = seedX;
    let y = seedY;

    const top   = carTopY(pz);
    const onCar = top > -90 && Math.abs(seedX) < 0.94;

    if (onCar && y < top) y = top;

    if (Math.abs(seedX) > 0.58 && pz > -3.2 && pz < 3.2) {
      const arch = 0.08 * Math.max(0, Math.sin((3.2 - Math.abs(pz)) / 3.2 * Math.PI));
      x = seedX > 0 ? seedX + arch : seedX - arch;
    }

    if (pz < -3.3) {
      const wt = Math.min((-3.3 - pz) / 3.0, 1.0);
      y += (seedY - y) * wt * 0.4;
    }

    pts.push(new THREE.Vector3(x, y, pz));
  }
  return pts;
}

// ── 5. Wand definitions ───────────────────────────────────────────
const wandDefs = [
  { x:  0.00, y:  0.08, radius: 0.022, opacity: 0.38, color: new THREE.Color(0x38d8ff) },
  { x: -0.32, y:  0.07, radius: 0.016, opacity: 0.32, color: new THREE.Color(0x28c4ee) },
  { x:  0.32, y:  0.07, radius: 0.016, opacity: 0.32, color: new THREE.Color(0x28c4ee) },
  { x: -0.70, y:  0.18, radius: 0.013, opacity: 0.28, color: new THREE.Color(0x20b0e0) },
  { x:  0.70, y:  0.18, radius: 0.013, opacity: 0.28, color: new THREE.Color(0x20b0e0) },
  { x:  0.00, y:  1.10, radius: 0.012, opacity: 0.22, color: new THREE.Color(0x60e0ff) },
  { x: -0.50, y: -0.28, radius: 0.011, opacity: 0.26, color: new THREE.Color(0x18a0cc) },
  { x:  0.50, y: -0.28, radius: 0.011, opacity: 0.26, color: new THREE.Color(0x18a0cc) },
];

// ── 6. Build meshes ───────────────────────────────────────────────
const smokeWands = wandDefs.map((def, i) => {
  const curve = new THREE.CatmullRomCurve3(buildWandPath(def.x, def.y, 80));
  const geo   = new THREE.TubeGeometry(curve, 160, def.radius, 10, false);

  const mat = new THREE.ShaderMaterial({
    vertexShader:   smokeVert,
    fragmentShader: smokeFrag,
    uniforms: {
      uColor:   { value: def.color },
      uTime:    { value: 0.0 },
      uOpacity: { value: def.opacity },
      uHead:    { value: 0.0 },
    },
    transparent: true,
    depthWrite:  false,
    blending:    THREE.NormalBlending,   // ← no additive stacking
    side:        THREE.DoubleSide,
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 2;
  scene.add(mesh);

  return {
    mat,
    phaseOffset: i / wandDefs.length,
    speedMult:   0.80 + Math.random() * 0.25,
  };
});

// ── 7. Animation loop ─────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // 40 mph → 0.26/s,  100 mph → 0.85/s
  const baseSpeed = 0.26 + ((currentSpeed - 40) / 60) * 0.59;

  smokeWands.forEach(({ mat, phaseOffset, speedMult }) => {
    mat.uniforms.uTime.value = elapsed;
    mat.uniforms.uHead.value = ((elapsed * baseSpeed * speedMult) + phaseOffset) % 1.0;
  });

  controls.update();
  composer.render();
}
animate();

// ── 8. Resize ─────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  bloomPass.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
