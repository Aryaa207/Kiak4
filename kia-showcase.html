<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2025 Kia K4 GT-Line | Aurora Black Pearl</title>

  <!-- Three.js + addons from CDN – no installation needed -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --accent: #60b8ff;
      --accent2: #38d9ff;
      --bg: #06060f;
      --text: #e2e8f0;
      --muted: rgba(255,255,255,0.35);
    }

    html, body {
      width: 100%; height: 100%;
      background: var(--bg);
      overflow: hidden;
      font-family: 'Rajdhani', sans-serif;
    }

    /* ── Canvas ── */
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    canvas { display: block; width: 100% !important; height: 100% !important; }

    /* ── Loading screen ── */
    #loader {
      position: fixed; inset: 0;
      background: var(--bg);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 20px; z-index: 100;
      transition: opacity 0.8s ease;
    }
    #loader.hidden { opacity: 0; pointer-events: none; }

    .loader-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(13px, 2.5vw, 18px);
      letter-spacing: .35em;
      color: var(--accent);
      text-shadow: 0 0 20px #60b8ff88;
    }
    .loader-bar-wrap {
      width: 220px; height: 2px;
      background: rgba(255,255,255,0.08);
      border-radius: 2px; overflow: hidden;
    }
    .loader-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px var(--accent);
    }
    .loader-pct {
      font-family: 'Orbitron', monospace;
      font-size: 11px; letter-spacing: .2em;
      color: var(--muted);
    }

    /* ── UI Chrome ── */
    .ui-top {
      position: fixed; top: 0; left: 0; right: 0;
      padding: 24px 32px;
      display: flex; align-items: flex-start; justify-content: space-between;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(6,6,15,0.8) 0%, transparent 100%);
    }

    .brand {
      display: flex; flex-direction: column; gap: 4px;
    }
    .brand-name {
      font-family: 'Orbitron', monospace;
      font-size: clamp(14px, 2.5vw, 22px);
      font-weight: 900;
      letter-spacing: .25em;
      color: #fff;
      text-shadow: 0 0 40px rgba(96,184,255,0.3);
    }
    .brand-sub {
      font-family: 'Orbitron', monospace;
      font-size: clamp(8px, 1.2vw, 10px);
      letter-spacing: .5em;
      color: var(--accent);
      opacity: 0.8;
    }

    .ui-stats {
      display: flex; flex-direction: column; align-items: flex-end; gap: 3px;
    }
    .stat-row {
      font-family: 'Orbitron', monospace;
      font-size: 9px; letter-spacing: .15em;
      color: var(--muted);
    }
    .stat-val { color: var(--accent); }

    /* ── Speed Panel ── */
    .speed-panel {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 20px 24px 28px;
      background: linear-gradient(to top, rgba(6,6,15,0.95) 0%, transparent 100%);
      display: flex; flex-direction: column; align-items: center; gap: 12px;
    }

    .speed-label {
      font-family: 'Orbitron', monospace;
      font-size: 11px; letter-spacing: .25em;
      color: var(--muted);
      display: flex; align-items: center; gap: 10px;
    }
    .speed-mph {
      color: #fff; font-size: 20px; font-weight: 600;
      text-shadow: 0 0 16px var(--accent);
      min-width: 40px; text-align: right;
    }

    /* Preset buttons */
    .speed-presets {
      display: flex; gap: 8px;
    }
    .preset-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.5);
      border-radius: 4px;
      padding: 5px 14px;
      font-family: 'Orbitron', monospace;
      font-size: 10px; letter-spacing: .15em;
      cursor: pointer;
      transition: all .2s;
    }
    .preset-btn:hover,
    .preset-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(96,184,255,0.08);
      box-shadow: 0 0 12px rgba(96,184,255,0.15);
    }

    /* Slider */
    .speed-slider {
      width: min(280px, 80vw);
      -webkit-appearance: none;
      appearance: none;
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent), 0 0 20px rgba(96,184,255,0.4);
      cursor: pointer;
      transition: transform .15s;
    }
    .speed-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }

    /* Hint */
    .hint {
      position: fixed;
      bottom: 130px; right: 24px;
      font-family: 'Rajdhani', sans-serif;
      font-size: 11px; letter-spacing: .1em;
      color: var(--muted);
      text-align: right;
      line-height: 1.8;
      pointer-events: none;
    }

    /* Vignette */
    .vignette {
      position: fixed; inset: 0;
      background: radial-gradient(ellipse at center, transparent 45%, rgba(6,6,15,0.7) 100%);
      pointer-events: none;
    }

    /* Corner accent lines */
    .corner { position: fixed; width: 40px; height: 40px; }
    .corner-tl { top: 16px; left: 16px; border-top: 1px solid rgba(96,184,255,0.3); border-left: 1px solid rgba(96,184,255,0.3); }
    .corner-tr { top: 16px; right: 16px; border-top: 1px solid rgba(96,184,255,0.3); border-right: 1px solid rgba(96,184,255,0.3); }
    .corner-bl { bottom: 90px; left: 16px; border-bottom: 1px solid rgba(96,184,255,0.3); border-left: 1px solid rgba(96,184,255,0.3); }
    .corner-br { bottom: 90px; right: 16px; border-bottom: 1px solid rgba(96,184,255,0.3); border-right: 1px solid rgba(96,184,255,0.3); }

    @media (max-width: 480px) {
      .ui-stats { display: none; }
      .hint { display: none; }
    }
  </style>
</head>
<body>

<!-- Loading screen -->
<div id="loader">
  <div class="loader-title">LOADING K4 GT-LINE</div>
  <div class="loader-bar-wrap"><div class="loader-bar" id="loader-bar"></div></div>
  <div class="loader-pct" id="loader-pct">0%</div>
</div>

<!-- Three.js canvas -->
<div id="canvas-container"></div>

<!-- Decorative corners -->
<div class="corner corner-tl"></div>
<div class="corner corner-tr"></div>
<div class="corner corner-bl"></div>
<div class="corner corner-br"></div>

<!-- Vignette -->
<div class="vignette"></div>

<!-- Top UI -->
<div class="ui-top">
  <div class="brand">
    <div class="brand-name">KIA K4 GT-LINE</div>
    <div class="brand-sub">AURORA BLACK PEARL · 2025</div>
  </div>
  <div class="ui-stats">
    <div class="stat-row">ENGINE &nbsp;<span class="stat-val" id="stat-engine">2.0L NATURALLY ASPIRATED</span></div>
    <div class="stat-row">OUTPUT &nbsp;<span class="stat-val">147 HP · 132 LB-FT</span></div>
    <div class="stat-row">DRIVE &nbsp;<span class="stat-val">FWD · CVT</span></div>
  </div>
</div>

<!-- Drag hint -->
<div class="hint">
  DRAG TO ROTATE<br/>
  SCROLL TO ZOOM
</div>

<!-- Speed panel -->
<div class="speed-panel">
  <div class="speed-label">
    AIRFLOW SIMULATION &nbsp;·&nbsp;
    <span class="speed-mph" id="speed-display">40</span>
    &nbsp;MPH
  </div>
  <div class="speed-presets">
    <button class="preset-btn active" data-speed="40">40</button>
    <button class="preset-btn" data-speed="60">60</button>
    <button class="preset-btn" data-speed="80">80</button>
    <button class="preset-btn" data-speed="100">100</button>
  </div>
  <input type="range" class="speed-slider" id="speed-slider" min="40" max="100" step="1" value="40"/>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader }     from 'three/addons/loaders/RGBELoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';

// ─────────────────────────────────────────────
// SPEED STATE
// ─────────────────────────────────────────────
let currentSpeed = 40; // mph

const slider       = document.getElementById('speed-slider');
const speedDisplay = document.getElementById('speed-display');
const presetBtns   = document.querySelectorAll('.preset-btn');

function setSpeed(v) {
  currentSpeed = v;
  slider.value = v;
  speedDisplay.textContent = v;
  presetBtns.forEach(b => b.classList.toggle('active', +b.dataset.speed === v));
}

slider.addEventListener('input', () => setSpeed(+slider.value));
presetBtns.forEach(b => b.addEventListener('click', () => setSpeed(+b.dataset.speed)));

// ─────────────────────────────────────────────
// RENDERER
// ─────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.3;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

// ─────────────────────────────────────────────
// SCENE + CAMERA
// ─────────────────────────────────────────────
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0x06060f);
scene.fog = new THREE.FogExp2(0x06060f, 0.04);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(5, 2, 5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan     = false;
controls.minDistance   = 3;
controls.maxDistance   = 12;
controls.minPolarAngle = 0.15;
controls.maxPolarAngle = Math.PI / 2.1;
controls.autoRotate    = true;
controls.autoRotateSpeed = 0.5;
controls.enableDamping = true;
controls.dampingFactor = 0.06;

// ─────────────────────────────────────────────
// LIGHTING
// ─────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.15));

const sun = new THREE.DirectionalLight(0xffffff, 1.4);
sun.position.set(5, 8, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far  = 25;
sun.shadow.camera.left = sun.shadow.camera.bottom = -6;
sun.shadow.camera.right = sun.shadow.camera.top   =  6;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x4488ff, 0.5);
fill.position.set(-5, 3, -4);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.3);
rim.position.set(0, 2, -6);
scene.add(rim);

// ─────────────────────────────────────────────
// HDRI ENVIRONMENT  (studio-like sky for sharp reflections)
// Using a public domain HDRI from Poly Haven via CDN
// ─────────────────────────────────────────────
const rgbeLoader = new RGBELoader();
rgbeLoader.load(
  'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr',
  (hdr) => {
    hdr.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = hdr;  // used for reflections only (not background)
  },
  undefined,
  () => {
    // Fallback if network blocked – create a synthetic env map
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envScene = new THREE.RoomEnvironment();
    scene.environment = pmrem.fromScene(envScene).texture;
    pmrem.dispose();
  }
);

// ─────────────────────────────────────────────
// GROUND SHADOW PLANE
// ─────────────────────────────────────────────
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.ShadowMaterial({ opacity: 0.45 })
);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.5;
ground.receiveShadow = true;
scene.add(ground);

// Subtle reflective floor
const floorMat = new THREE.MeshStandardMaterial({
  color: 0x0a0a14,
  metalness: 0.4,
  roughness: 0.6,
  envMapIntensity: 0.5,
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y  = -0.501;
scene.add(floor);

// ─────────────────────────────────────────────
// LOAD GLB MODEL
// ─────────────────────────────────────────────
const loaderBar = document.getElementById('loader-bar');
const loaderPct = document.getElementById('loader-pct');
const loaderEl  = document.getElementById('loader');

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

// ── Material presets ──────────────────────────
const AURORA_BLACK = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x080810),
  metalness: 0.9,
  roughness: 0.08,
  envMapIntensity: 3.0,
});

const CHROME = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0xc0c8d0),
  metalness: 1.0,
  roughness: 0.04,
  envMapIntensity: 3.5,
});

const GLASS = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color(0x8ab8d8),
  metalness: 0.0,
  roughness: 0.0,
  transmission: 0.9,
  thickness: 0.4,
  transparent: true,
  opacity: 0.25,
  envMapIntensity: 1.5,
});

const RUBBER = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x111111),
  metalness: 0.0,
  roughness: 0.95,
});

function isWhitish(mat) {
  if (!mat || !mat.color) return false;
  const c = mat.color;
  return c.r > 0.72 && c.g > 0.72 && c.b > 0.72;
}

function applyMaterials(model) {
  model.traverse((node) => {
    if (!node.isMesh) return;
    node.castShadow    = true;
    node.receiveShadow = true;

    const n   = node.name.toLowerCase();
    const mat = Array.isArray(node.material) ? node.material[0] : node.material;

    const isGlassByName  = n.includes('glass') || n.includes('window') ||
                           n.includes('windshield') || n.includes('wind') ||
                           n.includes('screen') || n.includes('lens') ||
                           n.includes('light') || n.includes('lamp');
    const isGlassByColor = isWhitish(mat);

    if (isGlassByName || isGlassByColor) {
      node.material = GLASS.clone();
      node.renderOrder = 1;
    } else if (n.includes('body') || n.includes('paint') || n.includes('panel') ||
               n.includes('hood') || n.includes('door') || n.includes('fender') ||
               n.includes('roof') || n.includes('trunk') || n.includes('bumper')) {
      node.material = AURORA_BLACK.clone();
    } else if (n.includes('chrome') || n.includes('trim') || n.includes('grille') ||
               n.includes('exhaust') || n.includes('mirror')) {
      node.material = CHROME.clone();
    } else if (n.includes('tyre') || n.includes('tire') || n.includes('rubber') ||
               n.includes('wheel') || n.includes('rim')) {
      node.material = RUBBER.clone();
    }
  });
}

gltfLoader.load(
  './kiak4.glb',                  // relative to index.html
  (gltf) => {
    applyMaterials(gltf.scene);
    gltf.scene.position.y = -0.5;
    scene.add(gltf.scene);

    // Hide loader
    loaderEl.classList.add('hidden');
    setTimeout(() => loaderEl.style.display = 'none', 900);
  },
  (xhr) => {
    if (xhr.lengthComputable) {
      const pct = Math.round(xhr.loaded / xhr.total * 100);
      loaderBar.style.width = pct + '%';
      loaderPct.textContent  = pct + '%';
    }
  },
  (err) => {
    console.error('GLB load error:', err);
    loaderPct.textContent = 'MODEL NOT FOUND – place kiak4.glb next to index.html';
    loaderBar.style.background = '#f87171';
  }
);


// ═══════════════════════════════════════════════════════════════════
// SMOKE WAND SYSTEM
//
// Architecture:
//  • 8 thick TubeGeometry tubes at key aero positions
//  • Custom GLSL shader: glowing head, transparent fading tail
//  • UnrealBloomPass so tubes glow against the black paint
//  • Tubes slide forward each frame using mesh.position.z
//    so you get true flowing motion without rebuilding geometry
// ═══════════════════════════════════════════════════════════════════

// ── 1. Bloom post-processing ─────────────────────────────────────
import { EffectComposer }  from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass }      from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass }      from 'three/addons/postprocessing/OutputPass.js';

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.4,   // bloom strength
  0.6,   // bloom radius
  0.05   // threshold – very low so wispy tubes still glow
);
composer.addPass(bloomPass);
composer.addPass(new OutputPass());

// ── 2. Custom GLSL shader ─────────────────────────────────────────
// TubeGeometry UV layout:
//   uv.x  = 0 (start/tail) → 1 (end/head)   [along tube length]
//   uv.y  = 0 → 1                              [around tube cross-section]
const smokeVert = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const smokeFrag = `
  uniform vec3  uColor;
  uniform float uTime;
  uniform float uOpacity;
  uniform float uProgress; // 0→1, head of the animated slug

  varying vec2 vUv;

  void main() {
    // ── Along-tube alpha: bright at head, fades to nothing at tail ──
    // vUv.x=1 is the geometric head of the tube.
    // We create a "slug" effect: only the section near uProgress is lit.
    float dist   = abs(vUv.x - uProgress);
    float slugLen = 0.55;              // fraction of tube that's "lit"
    float inSlug  = 1.0 - smoothstep(0.0, slugLen, dist);

    // The very tip glows brightest
    float tip    = pow(max(0.0, 1.0 - dist / 0.08), 3.0);

    // ── Radial alpha: bright in the core, fade at the tube edge ──
    float radial = sin(vUv.y * 3.14159); // 0 at seams, 1 at centre
    float core   = pow(radial, 0.7);

    // ── Combine ──
    float alpha  = inSlug * core * uOpacity;
    alpha       += tip   * core * uOpacity * 1.5;  // extra tip brightness

    // Subtle shimmer
    float shim = sin(vUv.x * 22.0 - uTime * 5.0) * 0.5 + 0.5;
    alpha *= (0.88 + shim * 0.12);

    // Head flare: tip is nearly white
    vec3 col = mix(uColor, vec3(0.85, 0.97, 1.0), tip * core);

    if (alpha < 0.004) discard;
    gl_FragColor = vec4(col, alpha);
  }
`;

// ── 3. Body silhouette ────────────────────────────────────────────
// Returns the top-surface Y of the car at a given Z station.
// Car occupies Z: -3.0 to +3.0  (nose=+Z, trunk=-Z)
function carTopY(pz) {
  if (pz >  3.3 || pz < -3.6) return -99;
  if (pz >  2.5) return -0.15 + (3.3 - pz) / 0.8 * 0.28;   // bumper rise
  if (pz >  0.5) return 0.13  + (2.5 - pz) / 2.0 * 0.68;   // hood climb
  if (pz > -0.5) return 0.81  + Math.sin((pz + 0.5) / 1.0 * Math.PI) * 0.05; // roof peak
  if (pz > -3.1) return 0.81  - (-0.5 - pz) / 2.6 * 0.83;  // fastback
  return -0.02;
}

// ── 4. Path builder ───────────────────────────────────────────────
// Builds a CatmullRom path for one smoke wand.
// seedX, seedY = far-upstream position (far in front of car).
// The path runs from Z=+7 (far front) to Z=-6 (wake).
function buildWandPath(seedX, seedY, nPts = 80) {
  const pts = [];
  for (let i = 0; i < nPts; i++) {
    const t  = i / (nPts - 1);
    const pz = 7.0 - t * 13.0;   // +7 → -6

    let x = seedX;
    let y = seedY;

    const top     = carTopY(pz);
    const onCar   = top > -90 && Math.abs(seedX) < 0.95;

    if (onCar) {
      // Push y upward to ride the body surface
      const clearance = 0.05 + Math.abs(seedX) * 0.03;
      if (y < top + clearance) {
        y = top + clearance;
      }
    }

    // Wheel arch splay: outer lanes puff outward over arches
    if (Math.abs(seedX) > 0.60 && pz > -3.2 && pz < 3.2) {
      const arch = 0.10 * Math.max(0, Math.sin((3.2 - Math.abs(pz)) / 3.2 * Math.PI));
      x = seedX > 0 ? seedX + arch : seedX - arch;
    }

    // Wake recovery: converge back toward far-field Y behind the car
    if (pz < -3.3) {
      const wt = Math.min((-3.3 - pz) / 3.0, 1.0);
      y += (seedY - y) * wt * 0.45;
    }

    pts.push(new THREE.Vector3(x, y, pz));
  }
  return pts;
}

// ── 5. Define the 8 smoke wands ───────────────────────────────────
//
//  Position key (looking from above, nose pointing +Z):
//    x=0       → centreline
//    x=±0.35   → just inside the A-pillars
//    x=±0.72   → over the door mirrors / shoulder
//    x=0, y=1.1 → high free-stream above roof
//    x=±0.52, y=-0.28 → underbody / sill
//
const wandDefs = [
  // 1. Centre hood → roofline → fastback
  { x:  0.00, y:  0.08, radius: 0.035, opacity: 0.62,
    color: new THREE.Color(0x38d8ff) },

  // 2. Left of centre (A-pillar line)
  { x: -0.35, y:  0.07, radius: 0.026, opacity: 0.50,
    color: new THREE.Color(0x28c8f0) },

  // 3. Right of centre (A-pillar line)
  { x:  0.35, y:  0.07, radius: 0.026, opacity: 0.50,
    color: new THREE.Color(0x28c8f0) },

  // 4. Left door mirror / shoulder
  { x: -0.72, y:  0.20, radius: 0.020, opacity: 0.42,
    color: new THREE.Color(0x20b8e8) },

  // 5. Right door mirror / shoulder
  { x:  0.72, y:  0.20, radius: 0.020, opacity: 0.42,
    color: new THREE.Color(0x20b8e8) },

  // 6. High free-stream (above roof – barely deflected)
  { x:  0.00, y:  1.15, radius: 0.018, opacity: 0.30,
    color: new THREE.Color(0x70eeff) },

  // 7. Left underbody / sill
  { x: -0.52, y: -0.28, radius: 0.016, opacity: 0.35,
    color: new THREE.Color(0x18a8d8) },

  // 8. Right underbody / sill
  { x:  0.52, y: -0.28, radius: 0.016, opacity: 0.35,
    color: new THREE.Color(0x18a8d8) },
];

// ── 6. Build geometry + materials ────────────────────────────────
const smokeWands = wandDefs.map((def, i) => {
  const pts   = buildWandPath(def.x, def.y, 80);
  const curve = new THREE.CatmullRomCurve3(pts);

  // TubeGeometry: tubularSegments=160 makes the curve silky smooth
  const geo   = new THREE.TubeGeometry(curve, 160, def.radius, 10, false);

  const mat   = new THREE.ShaderMaterial({
    vertexShader:   smokeVert,
    fragmentShader: smokeFrag,
    uniforms: {
      uColor:    { value: def.color },
      uTime:     { value: 0.0 },
      uOpacity:  { value: def.opacity },
      uProgress: { value: 1.0 },   // animated each frame
    },
    transparent: true,
    depthWrite:  false,
    blending:    THREE.AdditiveBlending,
    side:        THREE.DoubleSide,
  });

  const mesh = new THREE.Mesh(geo, mat);
  scene.add(mesh);

  return {
    mesh, mat,
    phaseOffset: (i / wandDefs.length),   // stagger so they don't all pulse together
    speedMult: 0.85 + Math.random() * 0.30,
  };
});

// ── 7. Animation loop ─────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta   = clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // 40 mph → progress speed 0.28/s,  100 mph → 0.90/s
  const baseSpeed = 0.28 + ((currentSpeed - 40) / 60) * 0.62;

  smokeWands.forEach(({ mat, phaseOffset, speedMult }) => {
    mat.uniforms.uTime.value = elapsed;

    // Animate the "slug" sweeping from tail (0) to head (1) and looping
    const raw = ((elapsed * baseSpeed * speedMult) + phaseOffset) % 1.0;
    // We want the slug to sweep 0→1, pause briefly, then reset
    // Use a sawtooth that slows at the tip for a satisfying "whoosh"
    mat.uniforms.uProgress.value = raw;
  });

  controls.update();
  composer.render();   // bloom-enabled render
}
animate();

// ── 8. Resize ─────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  bloomPass.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
