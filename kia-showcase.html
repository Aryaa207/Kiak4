<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2025 Kia K4 GT-Line | Aurora Black Pearl</title>

  <!--
    DEPLOYMENT CHECKLIST:
    1. Upload THIS FILE to GitHub repo as kia-showcase.html
    2. Upload kiak4.glb to the SAME repo root
    3. The GLB URL below is absolute — works from any domain including Squarespace
    4. Squarespace iframe: src="https://aryaa207.github.io/Kiak4/kia-showcase.html"
  -->

  <script type="importmap">
  {
    "imports": {
      "three":         "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    *, *::before, *::after { box-sizing:border-box; margin:0; padding:0; }
    :root { --accent:#60b8ff; --accent2:#38d9ff; --bg:#06060f; --muted:rgba(255,255,255,0.35); }

    /* margin:0 padding:0 on html prevents Squarespace wrapper from adding
       any gap around the canvas — the dark bg fills 100% of the iframe */
    html { margin:0; padding:0; width:100%; height:100%; background:#06060f; }
    body { margin:0; padding:0; width:100%; height:100%; background:#06060f; overflow:hidden; font-family:'Rajdhani',sans-serif; }
    #canvas-container { position:fixed; inset:0; margin:0; padding:0; }
    canvas { display:block; width:100%!important; height:100%!important; margin:0; padding:0; }

    /* ── Loader ── */
    #loader {
      position:fixed; inset:0; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:20px; z-index:100; transition:opacity 0.8s ease;
    }
    #loader.hidden { opacity:0; pointer-events:none; }
    #loader-status { font-family:'Orbitron',monospace; font-size:clamp(10px,2vw,13px); letter-spacing:.2em; color:var(--muted); margin-top:8px; max-width:80vw; text-align:center; }
    .loader-title { font-family:'Orbitron',monospace; font-size:clamp(13px,2.5vw,18px); letter-spacing:.35em; color:var(--accent); text-shadow:0 0 20px #60b8ff88; }
    .loader-bar-wrap { width:220px; height:2px; background:rgba(255,255,255,0.08); border-radius:2px; overflow:hidden; }
    .loader-bar { height:100%; background:linear-gradient(90deg,var(--accent),var(--accent2)); width:0%; transition:width 0.3s ease; box-shadow:0 0 10px var(--accent); }
    .loader-pct { font-family:'Orbitron',monospace; font-size:11px; letter-spacing:.2em; color:var(--muted); }

    /* ── Top UI ── */
    .ui-top { position:fixed; top:0; left:0; right:0; padding:24px 32px; display:flex; align-items:flex-start; justify-content:space-between; pointer-events:none; background:linear-gradient(to bottom,rgba(6,6,15,0.85) 0%,transparent 100%); }
    .brand { display:flex; flex-direction:column; gap:4px; }
    .brand-name { font-family:'Orbitron',monospace; font-size:clamp(14px,2.5vw,22px); font-weight:900; letter-spacing:.25em; color:#fff; text-shadow:0 0 40px rgba(96,184,255,0.3); }
    .brand-sub  { font-family:'Orbitron',monospace; font-size:clamp(8px,1.2vw,10px); letter-spacing:.5em; color:var(--accent); opacity:0.8; }
    .ui-stats { display:flex; flex-direction:column; align-items:flex-end; gap:3px; }
    .stat-row { font-family:'Orbitron',monospace; font-size:9px; letter-spacing:.15em; color:var(--muted); }
    .stat-val { color:var(--accent); }

    /* ── Speed panel ── */
    .speed-panel { position:fixed; bottom:0; left:0; right:0; padding:20px 24px 28px; background:linear-gradient(to top,rgba(6,6,15,0.95) 0%,transparent 100%); display:flex; flex-direction:column; align-items:center; gap:12px; }
    .speed-label { font-family:'Orbitron',monospace; font-size:11px; letter-spacing:.25em; color:var(--muted); display:flex; align-items:center; gap:10px; }
    .speed-mph   { color:#fff; font-size:20px; font-weight:600; text-shadow:0 0 16px var(--accent); min-width:40px; text-align:right; }
    .speed-presets { display:flex; gap:8px; }
    .preset-btn { background:transparent; border:1px solid rgba(255,255,255,0.12); color:rgba(255,255,255,0.5); border-radius:4px; padding:5px 14px; font-family:'Orbitron',monospace; font-size:10px; letter-spacing:.15em; cursor:pointer; transition:all .2s; }
    .preset-btn:hover, .preset-btn.active { border-color:var(--accent); color:var(--accent); background:rgba(96,184,255,0.08); box-shadow:0 0 12px rgba(96,184,255,0.15); }
    .speed-slider { width:min(280px,80vw); -webkit-appearance:none; appearance:none; height:2px; background:rgba(255,255,255,0.1); border-radius:2px; outline:none; cursor:pointer; }
    .speed-slider::-webkit-slider-thumb { -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); box-shadow:0 0 10px var(--accent),0 0 20px rgba(96,184,255,0.4); cursor:pointer; transition:transform .15s; }
    .speed-slider::-webkit-slider-thumb:hover { transform:scale(1.3); }

    /* ── Decor ── */
    .hint { position:fixed; bottom:130px; right:24px; font-family:'Rajdhani',sans-serif; font-size:11px; letter-spacing:.1em; color:var(--muted); text-align:right; line-height:1.8; pointer-events:none; }
    .vignette { position:fixed; inset:0; background:radial-gradient(ellipse at center,transparent 45%,rgba(6,6,15,0.65) 100%); pointer-events:none; }
    .corner { position:fixed; width:40px; height:40px; }
    .corner-tl { top:16px;    left:16px;   border-top:1px solid rgba(96,184,255,0.3); border-left:1px solid rgba(96,184,255,0.3); }
    .corner-tr { top:16px;    right:16px;  border-top:1px solid rgba(96,184,255,0.3); border-right:1px solid rgba(96,184,255,0.3); }
    .corner-bl { bottom:90px; left:16px;   border-bottom:1px solid rgba(96,184,255,0.3); border-left:1px solid rgba(96,184,255,0.3); }
    .corner-br { bottom:90px; right:16px;  border-bottom:1px solid rgba(96,184,255,0.3); border-right:1px solid rgba(96,184,255,0.3); }
    @media (max-width:480px) { .ui-stats,.hint { display:none; } }
  </style>
</head>
<body>

<div id="loader">
  <div class="loader-title">LOADING K4 GT-LINE</div>
  <div class="loader-bar-wrap"><div class="loader-bar" id="loader-bar"></div></div>
  <div class="loader-pct" id="loader-pct">0%</div>
  <div id="loader-status">Initialising…</div>
</div>

<div id="canvas-container"></div>
<div class="corner corner-tl"></div><div class="corner corner-tr"></div>
<div class="corner corner-bl"></div><div class="corner corner-br"></div>
<div class="vignette"></div>

<div class="ui-top">
  <div class="brand">
    <div class="brand-name">KIA K4 GT-LINE</div>
    <div class="brand-sub">AURORA BLACK PEARL · 2025</div>
  </div>
  <div class="ui-stats">
    <div class="stat-row">ENGINE &nbsp;<span class="stat-val">2.0L NATURALLY ASPIRATED</span></div>
    <div class="stat-row">OUTPUT &nbsp;<span class="stat-val">147 HP · 132 LB-FT</span></div>
    <div class="stat-row">DRIVE &nbsp;<span class="stat-val">FWD · CVT</span></div>
  </div>
</div>

<div class="hint">DRAG TO ROTATE<br/>SCROLL TO ZOOM</div>

<div class="speed-panel">
  <div class="speed-label">
    AIRFLOW SIMULATION &nbsp;·&nbsp;
    <span class="speed-mph" id="speed-display">40</span>&nbsp;MPH
  </div>
  <div class="speed-presets">
    <button class="preset-btn active" data-speed="40">40</button>
    <button class="preset-btn" data-speed="60">60</button>
    <button class="preset-btn" data-speed="80">80</button>
    <button class="preset-btn" data-speed="100">100</button>
  </div>
  <input type="range" class="speed-slider" id="speed-slider" min="40" max="100" step="1" value="40"/>
</div>

<script type="module">
import * as THREE        from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }    from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader }    from 'three/addons/loaders/RGBELoader.js';
import { DRACOLoader }   from 'three/addons/loaders/DRACOLoader.js';

// ─────────────────────────────────────────────────────────────────
// ABSOLUTE GLB URL  ← this is the key fix for Squarespace
// The file is served from GitHub Pages so any domain can load it.
// GitHub Pages sets permissive CORS headers on static assets.
// ─────────────────────────────────────────────────────────────────
const GLB_URL = 'https://aryaa207.github.io/Kiak4/kiak4.glb';

// ── Loader UI helpers ────────────────────────────────────────────
const loaderBar    = document.getElementById('loader-bar');
const loaderPct    = document.getElementById('loader-pct');
const loaderEl     = document.getElementById('loader');
const loaderStatus = document.getElementById('loader-status');

function setStatus(msg) { loaderStatus.textContent = msg; }
function hideLoader() {
  loaderEl.classList.add('hidden');
  setTimeout(() => loaderEl.style.display = 'none', 900);
}

// ── Speed state ──────────────────────────────────────────────────
let currentSpeed = 40;
const slider       = document.getElementById('speed-slider');
const speedDisplay = document.getElementById('speed-display');
const presetBtns   = document.querySelectorAll('.preset-btn');
function setSpeed(v) {
  currentSpeed = v; slider.value = v; speedDisplay.textContent = v;
  presetBtns.forEach(b => b.classList.toggle('active', +b.dataset.speed === v));
}
slider.addEventListener('input', () => setSpeed(+slider.value));
presetBtns.forEach(b => b.addEventListener('click', () => setSpeed(+b.dataset.speed)));

// ── Renderer ─────────────────────────────────────────────────────
// alpha:false + explicit setClearColor prevents the black-rectangle
// artifact caused by framebuffer alpha=0 patches.
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled   = true;
renderer.shadowMap.type      = THREE.PCFSoftShadowMap;
renderer.toneMapping         = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.3;
renderer.outputColorSpace    = THREE.SRGBColorSpace;
renderer.setClearColor(0x06060f, 1.0);  // matches scene.background — no alpha gap
document.getElementById('canvas-container').appendChild(renderer.domElement);

// ── Scene ────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06060f);
scene.fog = new THREE.FogExp2(0x06060f, 0.035);

// ── Camera ───────────────────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(5, 2, 5);

// ── Controls ─────────────────────────────────────────────────────
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan      = false;
controls.minDistance    = 3;
controls.maxDistance    = 14;
controls.minPolarAngle  = 0.1;
controls.maxPolarAngle  = Math.PI / 2.05;
controls.autoRotate     = true;
controls.autoRotateSpeed = 0.4;
controls.enableDamping  = true;
controls.dampingFactor  = 0.06;

// ── Lighting ─────────────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.18));

const sun = new THREE.DirectionalLight(0xffffff, 1.6);
sun.position.set(5, 8, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5; sun.shadow.camera.far  = 25;
sun.shadow.camera.left = sun.shadow.camera.bottom = -6;
sun.shadow.camera.right = sun.shadow.camera.top   =  6;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x4488ff, 0.6);
fill.position.set(-5, 3, -4); scene.add(fill);

const rim = new THREE.DirectionalLight(0x88ccff, 0.4);
rim.position.set(0, 2, -6); scene.add(rim);

// ── HDRI environment ─────────────────────────────────────────────
setStatus('Loading studio environment…');
const rgbeLoader = new RGBELoader();
rgbeLoader.load(
  'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr',
  (hdr) => {
    hdr.mapping    = THREE.EquirectangularReflectionMapping;
    hdr.minFilter  = THREE.LinearFilter;
    hdr.magFilter  = THREE.LinearFilter;
    scene.environment = hdr;
    setStatus('Loading car model…');
    loadCar();
  },
  undefined,
  () => {
    // Fallback to synthetic env if HDRI blocked
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envTex = pmrem.fromScene(new THREE.RoomEnvironment()).texture;
    envTex.minFilter = THREE.LinearFilter;
    envTex.magFilter = THREE.LinearFilter;
    scene.environment = envTex;
    pmrem.dispose();
    setStatus('Loading car model…');
    loadCar();
  }
);

// ── Ground ───────────────────────────────────────────────────────
const shadowGround = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.ShadowMaterial({ opacity: 0.5 })
);
shadowGround.rotation.x = -Math.PI / 2;
shadowGround.position.y = -0.5;
shadowGround.receiveShadow = true;
scene.add(shadowGround);

const reflectFloor = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshStandardMaterial({ color: 0x0a0a14, metalness: 0.4, roughness: 0.6, envMapIntensity: 0.6 })
);
reflectFloor.rotation.x = -Math.PI / 2;
reflectFloor.position.y = -0.501;
scene.add(reflectFloor);

// ── Material presets ─────────────────────────────────────────────
const MAT_AURORA = new THREE.MeshStandardMaterial({
  color: 0x080810, metalness: 0.92, roughness: 0.07, envMapIntensity: 3.2,
});
const MAT_CHROME = new THREE.MeshStandardMaterial({
  color: 0xc0c8d0, metalness: 1.0, roughness: 0.04, envMapIntensity: 3.5,
});
const MAT_GLASS = new THREE.MeshPhysicalMaterial({
  color: 0x8ab8d8, metalness: 0, roughness: 0,
  transmission: 0.9, thickness: 0.4,
  transparent: true, opacity: 0.25, envMapIntensity: 1.5,
});
const MAT_RUBBER = new THREE.MeshStandardMaterial({
  color: 0x111111, metalness: 0, roughness: 0.95,
});

function isWhitish(mat) {
  if (!mat?.color) return false;
  const { r, g, b } = mat.color;
  return r > 0.72 && g > 0.72 && b > 0.72;
}

// ── Wheel mesh refs  (populated by loadCar → applyMaterials) ─────
// These are rotated every frame proportional to currentSpeed.
const wheelMeshes = [];

function applyMaterials(model) {
  model.traverse((node) => {
    if (!node.isMesh) return;
    node.castShadow = node.receiveShadow = true;
    const n   = node.name.toLowerCase();
    const mat = Array.isArray(node.material) ? node.material[0] : node.material;

    const isGlass  = ['glass','window','windshield','wind','screen','lens','light','lamp'].some(k => n.includes(k)) || isWhitish(mat);
    const isBody   = ['body','paint','panel','hood','door','fender','roof','trunk','bumper'].some(k => n.includes(k));
    const isChrome = ['chrome','trim','grille','exhaust','mirror','badge'].some(k => n.includes(k));
    const isWheel  = ['wheel','tire','tyre','rim','brake','disc','caliper'].some(k => n.includes(k));

    if      (isGlass)  { node.material = MAT_GLASS.clone();  node.renderOrder = 1; }
    else if (isBody)   { node.material = MAT_AURORA.clone(); }
    else if (isChrome) { node.material = MAT_CHROME.clone(); }
    else if (isWheel)  { node.material = MAT_RUBBER.clone(); }

    // ── WHEEL SPIN: collect refs here, rotate in animate() ──────
    if (isWheel) {
      wheelMeshes.push(node);
      console.log('[K4 Wheel found]', node.name);
    }
  });
}

// ── Car loader ───────────────────────────────────────────────────
function loadCar() {
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
  const loader = new GLTFLoader();
  loader.setDRACOLoader(draco);

  console.log('[K4] Fetching:', GLB_URL);
  setStatus('Fetching model from GitHub…');

  loader.load(
    GLB_URL,
    (gltf) => {
      console.log('[K4] ✓ Model loaded. Children:', gltf.scene.children.length);
      console.log('[K4] Wheel meshes found:', wheelMeshes.length);
      applyMaterials(gltf.scene);
      gltf.scene.position.set(0, -0.5, 0);
      gltf.scene.scale.set(1, 1, 1);
      scene.add(gltf.scene);
      // ↓ MUST be called after scene.add so raycasts hit the car geometry
      buildSmokeWands(gltf.scene);
      hideLoader();
    },
    (xhr) => {
      if (xhr.lengthComputable && xhr.total > 0) {
        const p = Math.min(100, Math.round(xhr.loaded / xhr.total * 100));
        loaderBar.style.width = p + '%';
        loaderPct.textContent = p + '%';
        setStatus(`Downloading model… ${p}%`);
      }
    },
    (err) => {
      console.error('[K4] ✗ Load failed:', err);
      loaderPct.textContent = '⚠ MODEL FAILED TO LOAD';
      loaderBar.style.background = '#f87171';
      setStatus('Check browser console (F12) for details. Ensure kiak4.glb is in the GitHub repo root.');
    }
  );
}

// ─────────────────────────────────────────────────────────────────
// SMOKE WAND SYSTEM  v9  ─ Wispy Vapour Edition
//
// 35 ultra-thin wands in aerodynamic clusters.
// Shader: hash-based gradient noise stretched by speed → motion blur.
// Radial feathering: no hard tube edge, pure soft falloff.
// Surface guard: analytic carSurfaceY() with 0.02 clearance (stable,
// no raycaster kinks). Only uHead + uSpeed updated per frame.
// ─────────────────────────────────────────────────────────────────

const smokeVert = `
  varying vec2  vUv;
  varying float vLen;   // normalised along-tube position 0→1
  void main() {
    vUv  = uv;
    vLen = uv.x;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const smokeFrag = `
  uniform vec3  uColor;
  uniform float uOpacity;
  uniform float uHead;
  uniform float uSpeed;   // 0..1  (mapped from mph)

  varying vec2  vUv;
  varying float vLen;

  // ── Minimal 2-D value noise (no texture sampler needed) ──────────
  // Based on a hash of the UV coordinate — runs entirely on GPU.
  float hash(vec2 p) {
    p = fract(p * vec2(127.1, 311.7));
    p += dot(p, p + 19.19);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);   // smoothstep
    return mix(
      mix(hash(i),           hash(i + vec2(1,0)), u.x),
      mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x),
      u.y
    );
  }

  // Two octaves of noise for wispy detail
  float fbm(vec2 p) {
    float v = 0.0;
    v += 0.60 * noise(p);
    v += 0.30 * noise(p * 2.1 + vec2(5.2, 1.3));
    v += 0.10 * noise(p * 4.5 + vec2(2.4, 8.7));
    return v;
  }

  void main() {
    // ── Comet window: which part of the tube is currently lit ─────
    float behind = uHead - vLen;
    if (behind < 0.0) behind += 1.0;

    const float TAIL = 0.55;
    if (behind > TAIL) discard;

    // Along-tube fade: sharp nose → long wispy tail
    float along = pow(clamp(1.0 - behind / TAIL, 0.0, 1.0), 1.4);

    // ── Noise UV: stretch horizontally by speed for motion-blur ───
    // Higher speed → more horizontal stretch → elongated streaks
    float stretch = 6.0 + uSpeed * 18.0;   // 6× at rest, 24× at 100 mph
    vec2  noiseUV = vec2(
      vLen  * stretch - uHead * stretch,    // travels with the comet
      vUv.y * 1.8                           // slight vertical variation
    );

    float smoke = fbm(noiseUV);

    // ── Radial feathering: NO hard tube edge ──────────────────────
    // smoothstep both sides of the 0-1 radial UV for a cotton-soft edge
    float radial = smoothstep(0.0, 0.38, vUv.y) * smoothstep(1.0, 0.62, vUv.y);

    // ── Taper: thin at entry, thicker over car, wisp at tail ──────
    // vLen 0 = upstream end, 1 = downstream end
    // Peak thickness around 35-55% along the tube (over the car body)
    float taper = smoothstep(0.0, 0.20, vLen)    // thin approach
                * smoothstep(1.0, 0.55, vLen);    // wispy tail

    // ── Grain: tiny high-frequency grit on top of the smooth smoke ─
    float grain = hash(vUv * 94.7 + uHead * 13.3) * 0.18;

    float alpha = (smoke * 0.82 + grain) * radial * taper * along * uOpacity;
    alpha = clamp(alpha, 0.0, 1.0);
    if (alpha < 0.004) discard;

    // Colour: slight warm-white tint in dense noise regions
    vec3 col = mix(uColor, vec3(0.88, 0.97, 1.00), smoke * 0.22);

    gl_FragColor = vec4(col * alpha, alpha);
  }
`;

// ── Analytic car silhouette (surface guard) ───────────────────────
// CLEARANCE = 0.02  (2 cm) — the "raycaster safety" without the kinks.
// All values in world space (car sits at position.y = -0.5).
const CAR_Y_OFFSET = -0.5;
const CLEARANCE    =  0.02;

function carSurfaceY(pz) {
  if (pz >  3.6 || pz < -3.9) return -999;
  let localY;
  if      (pz >  2.9) localY = -0.12 + (3.6 - pz) / 0.7 * 0.22;
  else if (pz >  0.8) localY =  0.10 + (2.9 - pz) / 2.1 * 0.34;
  else if (pz > -0.3) localY =  0.44 + Math.sin((pz + 0.3) / 1.1 * Math.PI) * 0.04;
  else if (pz > -0.9) localY =  0.44;
  else if (pz > -3.5) localY =  0.44 - (-0.9 - pz) / 2.6 * 0.86;
  else                localY = -0.42;
  return CAR_Y_OFFSET + localY + CLEARANCE;
}

// ── Path builder ──────────────────────────────────────────────────
function buildPath(seedX, seedY) {
  const N   = 44;
  const pts = [];
  for (let i = 0; i < N; i++) {
    const t   = i / (N - 1);
    const pz  = 8.2 - t * 16.0;   // +8.2 upstream → -7.8 wake

    const surfY = carSurfaceY(pz);
    const onCar = surfY > -900 && Math.abs(seedX) < 1.15;

    const inRamp  = pz > 1.6 && pz < 3.5 && Math.abs(seedX) < 0.82;
    const rampAdd = inRamp ? 0.14 * Math.sin((pz - 1.6) / 1.9 * Math.PI) : 0;

    let y = seedY;
    if (onCar) y = Math.max(y, surfY + rampAdd);

    if (pz < -3.7) {
      const w = Math.min((-3.7 - pz) / 3.2, 1.0);
      y += (seedY - y) * w * 0.5;
    }

    let x = seedX;
    if (Math.abs(seedX) > 0.55 && pz > -3.6 && pz < 3.6) {
      const arch = 0.06 * Math.max(0, Math.sin((3.6 - Math.abs(pz)) / 3.6 * Math.PI));
      x = seedX > 0 ? seedX + arch : seedX - arch;
    }
    pts.push(new THREE.Vector3(x, y, pz));
  }
  return pts;
}

// ── Wand cluster definitions ──────────────────────────────────────
// 35 ultra-thin wands grouped in aerodynamic clusters.
// r  = tube radius (0.003–0.010 — very fine, like actual vapour)
// op = opacity    (0.10–0.28 — low, layered for density)
// spd = per-wand comet speed multiplier for organic variation
// dy  = tiny vertical jitter within a cluster
//
// Clusters:
//   A — centre spine (tight pack of 5 over the roof centreline)
//   B — inner pair   (3 wands each side, A-pillar region)
//   C — shoulder     (3 wands each side, door-mirror line)
//   D — fender       (2 wands each side)
//   E — outer        (2 wands each side, freely splaying)
//   F — high stream  (3 wands above the roofline)
//   G — underbody    (2 wands each side, sill channel)

const WAND_DEFS = [
  // ── Cluster A: Centre spine ──────────────────────────────────
  { x:  0.000, y: 0.180, r: 0.0090, op: 0.26, spd: 0.88 },
  { x:  0.000, y: 0.196, r: 0.0060, op: 0.18, spd: 1.04 },
  { x:  0.000, y: 0.210, r: 0.0045, op: 0.13, spd: 0.76 },
  { x:  0.012, y: 0.188, r: 0.0040, op: 0.12, spd: 1.12 },
  { x: -0.012, y: 0.188, r: 0.0040, op: 0.12, spd: 0.94 },

  // ── Cluster B: Inner / A-pillar ──────────────────────────────
  { x: -0.280, y: 0.200, r: 0.0080, op: 0.24, spd: 0.96 },
  { x: -0.295, y: 0.214, r: 0.0055, op: 0.16, spd: 1.08 },
  { x: -0.265, y: 0.208, r: 0.0042, op: 0.11, spd: 0.82 },
  { x:  0.280, y: 0.200, r: 0.0080, op: 0.24, spd: 1.06 },
  { x:  0.295, y: 0.214, r: 0.0055, op: 0.16, spd: 0.86 },
  { x:  0.265, y: 0.208, r: 0.0042, op: 0.11, spd: 1.14 },

  // ── Cluster C: Shoulder / door-mirror ────────────────────────
  { x: -0.570, y: 0.218, r: 0.0072, op: 0.22, spd: 1.00 },
  { x: -0.588, y: 0.230, r: 0.0048, op: 0.15, spd: 0.80 },
  { x: -0.552, y: 0.224, r: 0.0038, op: 0.10, spd: 1.16 },
  { x:  0.570, y: 0.218, r: 0.0072, op: 0.22, spd: 0.90 },
  { x:  0.588, y: 0.230, r: 0.0048, op: 0.15, spd: 1.10 },
  { x:  0.552, y: 0.224, r: 0.0038, op: 0.10, spd: 0.74 },

  // ── Cluster D: Fender crest ───────────────────────────────────
  { x: -0.840, y: 0.182, r: 0.0058, op: 0.18, spd: 0.84 },
  { x: -0.862, y: 0.194, r: 0.0038, op: 0.12, spd: 1.06 },
  { x:  0.840, y: 0.182, r: 0.0058, op: 0.18, spd: 1.18 },
  { x:  0.862, y: 0.194, r: 0.0038, op: 0.12, spd: 0.78 },

  // ── Cluster E: Outer / free-splay ────────────────────────────
  { x: -1.060, y: 0.222, r: 0.0045, op: 0.14, spd: 1.02 },
  { x: -1.080, y: 0.236, r: 0.0030, op: 0.10, spd: 0.88 },
  { x:  1.060, y: 0.222, r: 0.0045, op: 0.14, spd: 0.76 },
  { x:  1.080, y: 0.236, r: 0.0030, op: 0.10, spd: 1.10 },

  // ── Cluster F: High free-stream ───────────────────────────────
  { x:  0.000, y: 0.780, r: 0.0065, op: 0.20, spd: 0.92 },
  { x: -0.180, y: 0.754, r: 0.0042, op: 0.14, spd: 1.08 },
  { x:  0.180, y: 0.754, r: 0.0042, op: 0.14, spd: 0.82 },

  // ── Cluster G: Underbody sill ─────────────────────────────────
  { x: -0.620, y: -0.20, r: 0.0048, op: 0.16, spd: 1.04 },
  { x: -0.640, y: -0.21, r: 0.0030, op: 0.10, spd: 0.86 },
  { x:  0.620, y: -0.20, r: 0.0048, op: 0.16, spd: 0.80 },
  { x:  0.640, y: -0.21, r: 0.0030, op: 0.10, spd: 1.12 },

  // ── Two accent wands: slightly above free-stream, very faint ──
  { x: -0.380, y: 0.460, r: 0.0032, op: 0.10, spd: 0.98 },
  { x:  0.380, y: 0.460, r: 0.0032, op: 0.10, spd: 1.02 },
];

// ── Wand mesh array (filled by buildSmokeWands after GLB loads) ───
const smokeWands = [];

function buildSmokeWands() {
  WAND_DEFS.forEach((d, i) => {
    const curve = new THREE.CatmullRomCurve3(buildPath(d.x, d.y));
    // 100 tubular segments for ultra-smooth wispy curves
    // 6 radial segments — enough for the feathered shader, low poly cost
    const geo = new THREE.TubeGeometry(curve, 100, d.r, 6, false);
    geo.computeBoundingSphere();

    const mat = new THREE.ShaderMaterial({
      vertexShader:   smokeVert,
      fragmentShader: smokeFrag,
      uniforms: {
        uColor:   { value: new THREE.Color(0x5cd8f5) },
        uOpacity: { value: d.op },
        uHead:    { value: i / WAND_DEFS.length },   // stagger initial phases
        uSpeed:   { value: 0.0 },
      },
      transparent: true,
      depthWrite:  false,
      blending:    THREE.AdditiveBlending,
      side:        THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geo, mat);
    mesh.renderOrder   = 2;
    mesh.frustumCulled = true;
    scene.add(mesh);

    smokeWands.push({ mat, phase: i / WAND_DEFS.length, spd: d.spd });
  });
  console.log(`[K4] ✓ ${smokeWands.length} wispy vapour wands built`);
}

// ─────────────────────────────────────────────────────────────────
// ANIMATION LOOP
// ─────────────────────────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta   = clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // ── Wispy vapour animation ────────────────────────────────────────
  // uHead:  comet position 0→1 along the tube, per-wand phase stagger
  // uSpeed: 0→1 normalised from MPH — drives noise stretch (motion blur)
  const normSpeed = (currentSpeed - 40) / 60;           // 0 at 40mph, 1 at 100mph
  const flowRate  = 0.38 + normSpeed * 0.74;            // 0.38–1.12 tube-lengths/s
  for (const { mat, phase, spd } of smokeWands) {
    mat.uniforms.uHead.value  = ((elapsed * flowRate * spd) + phase) % 1.0;
    mat.uniforms.uSpeed.value = normSpeed;
  }

  // ── WHEEL SPIN ───────────────────────────────────────────────
  // Physics: rad/s = linear_speed_m_s / wheel_radius_m
  // 40 mph = 17.88 m/s → at r=0.33m → 54.2 rad/s real
  // Visual scale factor 0.010 keeps it looking right in scene units
  // Multiply by delta (seconds since last frame) for frame-rate independence
  const wheelRadPerSec = (currentSpeed * 0.44704 / 0.33) * 0.010;
  for (const m of wheelMeshes) {
    m.rotation.x -= wheelRadPerSec * delta;
  }

  controls.update();
  renderer.render(scene, camera);  // single direct render — no composer, no artifacts
}
animate();

// ── Resize ───────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
