<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2025 Kia K4 GT-Line | Aurora Black Pearl</title>

  <!--
    DEPLOYMENT CHECKLIST:
    1. Upload THIS FILE to GitHub repo as kia-showcase.html
    2. Upload kiak4.glb to the SAME repo root
    3. The GLB URL below is absolute — works from any domain including Squarespace
    4. Squarespace iframe: src="https://aryaa207.github.io/Kiak4/kia-showcase.html"
  -->

  <script type="importmap">
  {
    "imports": {
      "three":         "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    *, *::before, *::after { box-sizing:border-box; margin:0; padding:0; }
    :root { --accent:#60b8ff; --accent2:#38d9ff; --bg:#06060f; --muted:rgba(255,255,255,0.35); }

    /* margin:0 padding:0 on html prevents Squarespace wrapper from adding
       any gap around the canvas — the dark bg fills 100% of the iframe */
    html { margin:0; padding:0; width:100%; height:100%; background:#06060f; }
    body { margin:0; padding:0; width:100%; height:100%; background:#06060f; overflow:hidden; font-family:'Rajdhani',sans-serif; }
    #canvas-container { position:fixed; inset:0; margin:0; padding:0; }
    canvas { display:block; width:100%!important; height:100%!important; margin:0; padding:0; }

    /* ── Loader ── */
    #loader {
      position:fixed; inset:0; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:20px; z-index:100; transition:opacity 0.8s ease;
    }
    #loader.hidden { opacity:0; pointer-events:none; }
    #loader-status { font-family:'Orbitron',monospace; font-size:clamp(10px,2vw,13px); letter-spacing:.2em; color:var(--muted); margin-top:8px; max-width:80vw; text-align:center; }
    .loader-title { font-family:'Orbitron',monospace; font-size:clamp(13px,2.5vw,18px); letter-spacing:.35em; color:var(--accent); text-shadow:0 0 20px #60b8ff88; }
    .loader-bar-wrap { width:220px; height:2px; background:rgba(255,255,255,0.08); border-radius:2px; overflow:hidden; }
    .loader-bar { height:100%; background:linear-gradient(90deg,var(--accent),var(--accent2)); width:0%; transition:width 0.3s ease; box-shadow:0 0 10px var(--accent); }
    .loader-pct { font-family:'Orbitron',monospace; font-size:11px; letter-spacing:.2em; color:var(--muted); }

    /* ── Top UI ── */
    .ui-top { position:fixed; top:0; left:0; right:0; padding:24px 32px; display:flex; align-items:flex-start; justify-content:space-between; pointer-events:none; background:linear-gradient(to bottom,rgba(6,6,15,0.85) 0%,transparent 100%); }
    .brand { display:flex; flex-direction:column; gap:4px; }
    .brand-name { font-family:'Orbitron',monospace; font-size:clamp(14px,2.5vw,22px); font-weight:900; letter-spacing:.25em; color:#fff; text-shadow:0 0 40px rgba(96,184,255,0.3); }
    .brand-sub  { font-family:'Orbitron',monospace; font-size:clamp(8px,1.2vw,10px); letter-spacing:.5em; color:var(--accent); opacity:0.8; }
    .ui-stats { display:flex; flex-direction:column; align-items:flex-end; gap:3px; }
    .stat-row { font-family:'Orbitron',monospace; font-size:9px; letter-spacing:.15em; color:var(--muted); }
    .stat-val { color:var(--accent); }

    /* ── Speed panel ── */
    .speed-panel { position:fixed; bottom:0; left:0; right:0; padding:20px 24px 28px; background:linear-gradient(to top,rgba(6,6,15,0.95) 0%,transparent 100%); display:flex; flex-direction:column; align-items:center; gap:12px; }
    .speed-label { font-family:'Orbitron',monospace; font-size:11px; letter-spacing:.25em; color:var(--muted); display:flex; align-items:center; gap:10px; }
    .speed-mph   { color:#fff; font-size:20px; font-weight:600; text-shadow:0 0 16px var(--accent); min-width:40px; text-align:right; }
    .speed-presets { display:flex; gap:8px; }
    .preset-btn { background:transparent; border:1px solid rgba(255,255,255,0.12); color:rgba(255,255,255,0.5); border-radius:4px; padding:5px 14px; font-family:'Orbitron',monospace; font-size:10px; letter-spacing:.15em; cursor:pointer; transition:all .2s; }
    .preset-btn:hover, .preset-btn.active { border-color:var(--accent); color:var(--accent); background:rgba(96,184,255,0.08); box-shadow:0 0 12px rgba(96,184,255,0.15); }
    .speed-slider { width:min(280px,80vw); -webkit-appearance:none; appearance:none; height:2px; background:rgba(255,255,255,0.1); border-radius:2px; outline:none; cursor:pointer; }
    .speed-slider::-webkit-slider-thumb { -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); box-shadow:0 0 10px var(--accent),0 0 20px rgba(96,184,255,0.4); cursor:pointer; transition:transform .15s; }
    .speed-slider::-webkit-slider-thumb:hover { transform:scale(1.3); }

    /* ── Decor ── */
    .hint { position:fixed; bottom:130px; right:24px; font-family:'Rajdhani',sans-serif; font-size:11px; letter-spacing:.1em; color:var(--muted); text-align:right; line-height:1.8; pointer-events:none; }
    .vignette { position:fixed; inset:0; background:radial-gradient(ellipse at center,transparent 45%,rgba(6,6,15,0.65) 100%); pointer-events:none; }
    .corner { position:fixed; width:40px; height:40px; }
    .corner-tl { top:16px;    left:16px;   border-top:1px solid rgba(96,184,255,0.3); border-left:1px solid rgba(96,184,255,0.3); }
    .corner-tr { top:16px;    right:16px;  border-top:1px solid rgba(96,184,255,0.3); border-right:1px solid rgba(96,184,255,0.3); }
    .corner-bl { bottom:90px; left:16px;   border-bottom:1px solid rgba(96,184,255,0.3); border-left:1px solid rgba(96,184,255,0.3); }
    .corner-br { bottom:90px; right:16px;  border-bottom:1px solid rgba(96,184,255,0.3); border-right:1px solid rgba(96,184,255,0.3); }
    @media (max-width:480px) { .ui-stats,.hint { display:none; } }
  </style>
</head>
<body>

<div id="loader">
  <div class="loader-title">LOADING K4 GT-LINE</div>
  <div class="loader-bar-wrap"><div class="loader-bar" id="loader-bar"></div></div>
  <div class="loader-pct" id="loader-pct">0%</div>
  <div id="loader-status">Initialising…</div>
</div>

<div id="canvas-container"></div>
<div class="corner corner-tl"></div><div class="corner corner-tr"></div>
<div class="corner corner-bl"></div><div class="corner corner-br"></div>
<div class="vignette"></div>

<div class="ui-top">
  <div class="brand">
    <div class="brand-name">KIA K4 GT-LINE</div>
    <div class="brand-sub">AURORA BLACK PEARL · 2025</div>
  </div>
  <div class="ui-stats">
    <div class="stat-row">ENGINE &nbsp;<span class="stat-val">2.0L NATURALLY ASPIRATED</span></div>
    <div class="stat-row">OUTPUT &nbsp;<span class="stat-val">147 HP · 132 LB-FT</span></div>
    <div class="stat-row">DRIVE &nbsp;<span class="stat-val">FWD · CVT</span></div>
  </div>
</div>

<div class="hint">DRAG TO ROTATE<br/>SCROLL TO ZOOM</div>

<div class="speed-panel">
  <div class="speed-label">
    AIRFLOW SIMULATION &nbsp;·&nbsp;
    <span class="speed-mph" id="speed-display">40</span>&nbsp;MPH
  </div>
  <div class="speed-presets">
    <button class="preset-btn active" data-speed="40">40</button>
    <button class="preset-btn" data-speed="60">60</button>
    <button class="preset-btn" data-speed="80">80</button>
    <button class="preset-btn" data-speed="100">100</button>
  </div>
  <input type="range" class="speed-slider" id="speed-slider" min="40" max="100" step="1" value="40"/>
</div>

<script type="module">
import * as THREE        from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }    from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader }    from 'three/addons/loaders/RGBELoader.js';
import { DRACOLoader }   from 'three/addons/loaders/DRACOLoader.js';

// ─────────────────────────────────────────────────────────────────
// ABSOLUTE GLB URL  ← this is the key fix for Squarespace
// The file is served from GitHub Pages so any domain can load it.
// GitHub Pages sets permissive CORS headers on static assets.
// ─────────────────────────────────────────────────────────────────
const GLB_URL = 'https://aryaa207.github.io/Kiak4/kiak4.glb';

// ── Loader UI helpers ────────────────────────────────────────────
const loaderBar    = document.getElementById('loader-bar');
const loaderPct    = document.getElementById('loader-pct');
const loaderEl     = document.getElementById('loader');
const loaderStatus = document.getElementById('loader-status');

function setStatus(msg) { loaderStatus.textContent = msg; }
function hideLoader() {
  loaderEl.classList.add('hidden');
  setTimeout(() => loaderEl.style.display = 'none', 900);
}

// ── Speed state ──────────────────────────────────────────────────
let currentSpeed = 40;
const slider       = document.getElementById('speed-slider');
const speedDisplay = document.getElementById('speed-display');
const presetBtns   = document.querySelectorAll('.preset-btn');
function setSpeed(v) {
  currentSpeed = v; slider.value = v; speedDisplay.textContent = v;
  presetBtns.forEach(b => b.classList.toggle('active', +b.dataset.speed === v));
}
slider.addEventListener('input', () => setSpeed(+slider.value));
presetBtns.forEach(b => b.addEventListener('click', () => setSpeed(+b.dataset.speed)));

// ── Renderer ─────────────────────────────────────────────────────
// alpha:false + explicit setClearColor prevents the black-rectangle
// artifact caused by framebuffer alpha=0 patches.
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled   = true;
renderer.shadowMap.type      = THREE.PCFSoftShadowMap;
renderer.toneMapping         = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.3;
renderer.outputColorSpace    = THREE.SRGBColorSpace;
renderer.setClearColor(0x06060f, 1.0);  // matches scene.background — no alpha gap
document.getElementById('canvas-container').appendChild(renderer.domElement);

// ── Scene ────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06060f);
scene.fog = new THREE.FogExp2(0x06060f, 0.035);

// ── Camera ───────────────────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(5, 2, 5);

// ── Controls ─────────────────────────────────────────────────────
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan      = false;
controls.minDistance    = 3;
controls.maxDistance    = 14;
controls.minPolarAngle  = 0.1;
controls.maxPolarAngle  = Math.PI / 2.05;
controls.autoRotate     = true;
controls.autoRotateSpeed = 0.4;
controls.enableDamping  = true;
controls.dampingFactor  = 0.06;

// ── Lighting ─────────────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.18));

const sun = new THREE.DirectionalLight(0xffffff, 1.6);
sun.position.set(5, 8, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5; sun.shadow.camera.far  = 25;
sun.shadow.camera.left = sun.shadow.camera.bottom = -6;
sun.shadow.camera.right = sun.shadow.camera.top   =  6;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x4488ff, 0.6);
fill.position.set(-5, 3, -4); scene.add(fill);

const rim = new THREE.DirectionalLight(0x88ccff, 0.4);
rim.position.set(0, 2, -6); scene.add(rim);

// ── HDRI environment ─────────────────────────────────────────────
setStatus('Loading studio environment…');
const rgbeLoader = new RGBELoader();
rgbeLoader.load(
  'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr',
  (hdr) => {
    hdr.mapping    = THREE.EquirectangularReflectionMapping;
    hdr.minFilter  = THREE.LinearFilter;
    hdr.magFilter  = THREE.LinearFilter;
    scene.environment = hdr;
    setStatus('Loading car model…');
    loadCar();
  },
  undefined,
  () => {
    // Fallback to synthetic env if HDRI blocked
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envTex = pmrem.fromScene(new THREE.RoomEnvironment()).texture;
    envTex.minFilter = THREE.LinearFilter;
    envTex.magFilter = THREE.LinearFilter;
    scene.environment = envTex;
    pmrem.dispose();
    setStatus('Loading car model…');
    loadCar();
  }
);

// ── Ground ───────────────────────────────────────────────────────
const shadowGround = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.ShadowMaterial({ opacity: 0.5 })
);
shadowGround.rotation.x = -Math.PI / 2;
shadowGround.position.y = -0.5;
shadowGround.receiveShadow = true;
scene.add(shadowGround);

const reflectFloor = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshStandardMaterial({ color: 0x0a0a14, metalness: 0.4, roughness: 0.6, envMapIntensity: 0.6 })
);
reflectFloor.rotation.x = -Math.PI / 2;
reflectFloor.position.y = -0.501;
scene.add(reflectFloor);

// ── Material presets ─────────────────────────────────────────────
const MAT_AURORA = new THREE.MeshStandardMaterial({
  color: 0x080810, metalness: 0.92, roughness: 0.07, envMapIntensity: 3.2,
});
const MAT_CHROME = new THREE.MeshStandardMaterial({
  color: 0xc0c8d0, metalness: 1.0, roughness: 0.04, envMapIntensity: 3.5,
});
const MAT_GLASS = new THREE.MeshPhysicalMaterial({
  color: 0x8ab8d8, metalness: 0, roughness: 0,
  transmission: 0.9, thickness: 0.4,
  transparent: true, opacity: 0.25, envMapIntensity: 1.5,
});
const MAT_RUBBER = new THREE.MeshStandardMaterial({
  color: 0x111111, metalness: 0, roughness: 0.95,
});

function isWhitish(mat) {
  if (!mat?.color) return false;
  const { r, g, b } = mat.color;
  return r > 0.72 && g > 0.72 && b > 0.72;
}

// ── Wheel mesh refs  (populated by loadCar → applyMaterials) ─────
// These are rotated every frame proportional to currentSpeed.
const wheelMeshes = [];

function applyMaterials(model) {
  model.traverse((node) => {
    if (!node.isMesh) return;
    node.castShadow = node.receiveShadow = true;
    const n   = node.name.toLowerCase();
    const mat = Array.isArray(node.material) ? node.material[0] : node.material;

    const isGlass  = ['glass','window','windshield','wind','screen','lens','light','lamp'].some(k => n.includes(k)) || isWhitish(mat);
    const isBody   = ['body','paint','panel','hood','door','fender','roof','trunk','bumper'].some(k => n.includes(k));
    const isChrome = ['chrome','trim','grille','exhaust','mirror','badge'].some(k => n.includes(k));
    const isWheel  = ['wheel','tire','tyre','rim','brake','disc','caliper'].some(k => n.includes(k));

    if      (isGlass)  { node.material = MAT_GLASS.clone();  node.renderOrder = 1; }
    else if (isBody)   { node.material = MAT_AURORA.clone(); }
    else if (isChrome) { node.material = MAT_CHROME.clone(); }
    else if (isWheel)  { node.material = MAT_RUBBER.clone(); }

    // ── WHEEL SPIN: collect refs here, rotate in animate() ──────
    if (isWheel) {
      wheelMeshes.push(node);
      console.log('[K4 Wheel found]', node.name);
    }
  });
}

// ── Car loader ───────────────────────────────────────────────────
function loadCar() {
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
  const loader = new GLTFLoader();
  loader.setDRACOLoader(draco);

  console.log('[K4] Fetching:', GLB_URL);
  setStatus('Fetching model from GitHub…');

  loader.load(
    GLB_URL,
    (gltf) => {
      console.log('[K4] ✓ Model loaded. Children:', gltf.scene.children.length);
      console.log('[K4] Wheel meshes found:', wheelMeshes.length);
      applyMaterials(gltf.scene);
      gltf.scene.position.set(0, -0.5, 0);
      gltf.scene.scale.set(1, 1, 1);
      scene.add(gltf.scene);
      // ↓ MUST be called after scene.add so raycasts hit the car geometry
      buildSmokeWands(gltf.scene);
      hideLoader();
    },
    (xhr) => {
      if (xhr.lengthComputable && xhr.total > 0) {
        const p = Math.min(100, Math.round(xhr.loaded / xhr.total * 100));
        loaderBar.style.width = p + '%';
        loaderPct.textContent = p + '%';
        setStatus(`Downloading model… ${p}%`);
      }
    },
    (err) => {
      console.error('[K4] ✗ Load failed:', err);
      loaderPct.textContent = '⚠ MODEL FAILED TO LOAD';
      loaderBar.style.background = '#f87171';
      setStatus('Check browser console (F12) for details. Ensure kiak4.glb is in the GitHub repo root.');
    }
  );
}

// ─────────────────────────────────────────────────────────────────
// SMOKE WAND SYSTEM  v8  ─ Smooth Surface-Aware Edition
//
// Path:   Mathematical silhouette (smooth, no kinks) — same as the
//         version you liked — but now built after GLB load so we can
//         also account for the car's actual world Y offset (-0.5).
// Shader: Single clean travelling head + radial taper.
//         Only uHead updated per frame — zero geometry cost.
// ─────────────────────────────────────────────────────────────────

const smokeVert = `
  varying vec2 vUv;
  void main() {
    vUv         = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

// Travelling-head comet shader.
// uHead marches 0→1 continuously. Only 45% of the tube is lit at any
// moment — a bright nose fading to a long glowing tail. This makes the
// motion obvious rather than looking like a static glow ribbon.
const smokeFrag = `
  uniform vec3  uColor;
  uniform float uOpacity;
  uniform float uHead;
  varying vec2  vUv;

  void main() {
    // How far is this fragment behind the bright head?
    float behind = uHead - vUv.x;
    if (behind < 0.0) behind += 1.0;

    // Only render the tail segment (45% of tube length)
    const float TAIL = 0.45;
    if (behind > TAIL) discard;

    // Along-tube: full brightness at head, cubic falloff to tail
    float along = pow(clamp(1.0 - behind / TAIL, 0.0, 1.0), 1.6);

    // Sharp bright nose — tiny zone at the very tip
    float nose  = pow(clamp(1.0 - behind / 0.045, 0.0, 1.0), 2.8);

    // Radial: bright glowing core, feathered edges
    float r    = clamp(sin(vUv.y * 3.14159265), 0.0, 1.0);
    float core = pow(r, 1.3);

    // Secondary inner glow ring for depth
    float glow = pow(r, 0.5) * 0.25;

    float alpha = clamp((along * core + nose * 0.9 + glow * along * 0.3) * uOpacity, 0.0, 1.0);
    if (alpha < 0.005) discard;

    // Nose tip brightens toward white/teal for the leading edge flash
    vec3 noseCol = vec3(0.85, 0.98, 1.00);
    vec3 bodyCol = uColor * 1.6;   // amplify for AdditiveBlending pop
    vec3 col     = clamp(mix(bodyCol, noseCol, nose * core * 0.70), 0.0, 1.0);

    gl_FragColor = vec4(col * alpha, alpha);
  }
`;

// ── Mathematical car silhouette ───────────────────────────────────
// Measured world-space Y (car at position.y = -0.5):
//   Roof crown:      ≈ -0.04   (model local ~+0.46)
//   Windshield base: ≈ -0.01
//   Hood peak:       ≈ -0.25   (model local ~+0.25)
//   Front bumper:    ≈ -0.62   (model local ~-0.12)
//   Door sill / side:≈ -0.55   (mid-body at z=0)
//   Underbody:       ≈ -0.55 to -0.65
//
// CLEARANCE = 0.15 so the tube (max r=0.052) clears even the
// sharpest roof curve without any fragment poking through.
const CAR_Y_OFFSET = -0.5;
const CLEARANCE    =  0.15;

function carSurfaceY(pz) {
  // Returns world-space Y of the car's top surface at depth pz.
  // -999 = no car here (open air).
  if (pz >  3.6 || pz < -3.9) return -999;

  let localY;  // model-local Y before the -0.5 scene offset
  if      (pz >  2.9) localY = -0.12 + (3.6 - pz) / 0.7 * 0.22;  // front bumper ramp
  else if (pz >  0.8) localY =  0.10 + (2.9 - pz) / 2.1 * 0.34;  // hood slope up to windshield
  else if (pz > -0.3) localY =  0.44 + Math.sin((pz + 0.3) / 1.1 * Math.PI) * 0.04; // roof crown
  else if (pz > -0.9) localY =  0.44;                              // roof flat section
  else if (pz > -3.5) localY =  0.44 - (-0.9 - pz) / 2.6 * 0.86; // fastback slope
  else                localY = -0.42 + (-3.5 - pz) / 0.4 * (-0.05); // trunk/bumper

  return CAR_Y_OFFSET + localY + CLEARANCE;
}

// ── Path builder ──────────────────────────────────────────────────
function buildPath(seedX, seedY) {
  const N   = 40;
  const pts = [];

  for (let i = 0; i < N; i++) {
    const t  = i / (N - 1);
    const pz = 8.0 - t * 15.5;   // +8.0 upstream → -7.5 wake

    const surfY = carSurfaceY(pz);
    // Full body width — constraint applies inside ±1.15 of centre
    const onCar = surfY > -900 && Math.abs(seedX) < 1.15;

    // Extra arc over grille/bumper transition
    const inRamp  = pz > 1.6 && pz < 3.5 && Math.abs(seedX) < 0.80;
    const rampAdd = inRamp ? 0.16 * Math.sin((pz - 1.6) / 1.9 * Math.PI) : 0;

    let y = seedY;
    if (onCar) y = Math.max(y, surfY + rampAdd);

    // Wake: smooth blend back to freestream after the car ends
    if (pz < -3.7) {
      const w = Math.min((-3.7 - pz) / 3.0, 1.0);
      y += (seedY - y) * w * 0.55;
    }

    // Lateral splay over wheel arches
    let x = seedX;
    if (Math.abs(seedX) > 0.55 && pz > -3.6 && pz < 3.6) {
      const arch = 0.07 * Math.max(0, Math.sin((3.6 - Math.abs(pz)) / 3.6 * Math.PI));
      x = seedX > 0 ? seedX + arch : seedX - arch;
    }

    pts.push(new THREE.Vector3(x, y, pz));
  }
  return pts;
}

// ── Wand definitions ──────────────────────────────────────────────
// Seed Y values calibrated to measured world-space positions.
// Roof world Y ≈ -0.04, so freestream for over-body wands starts
// at Y = +0.18 (0.22 above roof crown) — well clear with CLEARANCE.
// Underbody floor ≈ -0.65, so underbody wands at Y = -0.38 are
// 0.27 above the floor (safely in the sill airstream zone).
const WAND_DEFS = [
  // Centre spine — thickest ribbon, just above roofline
  { x:  0.00, y:  0.18, r: 0.052, op: 0.78, spd: 0.90 },

  // ±0.30 — inner / A-pillar stream
  { x: -0.30, y:  0.20, r: 0.040, op: 0.68, spd: 1.06 },
  { x:  0.30, y:  0.20, r: 0.040, op: 0.68, spd: 0.84 },

  // ±0.58 — shoulder / door-mirror line
  { x: -0.58, y:  0.22, r: 0.034, op: 0.58, spd: 0.96 },
  { x:  0.58, y:  0.22, r: 0.034, op: 0.58, spd: 1.10 },

  // ±0.85 — fender crest (outside body, lower approach)
  { x: -0.85, y:  0.18, r: 0.026, op: 0.46, spd: 0.78 },
  { x:  0.85, y:  0.18, r: 0.026, op: 0.46, spd: 1.16 },

  // ±1.08 — fully outside body, free-splay (raised above side-mirror height)
  { x: -1.08, y:  0.22, r: 0.018, op: 0.36, spd: 1.04 },
  { x:  1.08, y:  0.22, r: 0.018, op: 0.36, spd: 0.72 },

  // High free-stream — well above roof, reads at any camera angle
  { x:  0.00, y:  0.80, r: 0.022, op: 0.36, spd: 0.94 },
  { x: -0.20, y:  0.76, r: 0.014, op: 0.26, spd: 1.08 },
  { x:  0.20, y:  0.76, r: 0.014, op: 0.26, spd: 0.80 },

  // Underbody sill — these are OUTSIDE the car body laterally so no
  // surface conflict; they ride in the low-pressure sill channel
  { x: -0.62, y: -0.20, r: 0.016, op: 0.32, spd: 1.02 },
  { x:  0.62, y: -0.20, r: 0.016, op: 0.32, spd: 0.76 },
];

// ── smokeWands (filled after GLB loads) ───────────────────────────
const smokeWands = [];

// ── buildSmokeWands — called ONCE inside the GLB success callback ──
function buildSmokeWands() {
  WAND_DEFS.forEach((d, i) => {
    const curve = new THREE.CatmullRomCurve3(buildPath(d.x, d.y));
    const geo   = new THREE.TubeGeometry(curve, 80, d.r, 8, false);
    geo.computeBoundingSphere();

    const mat = new THREE.ShaderMaterial({
      vertexShader: smokeVert, fragmentShader: smokeFrag,
      uniforms: {
        uColor:   { value: new THREE.Color(0x38d8ff) },
        uOpacity: { value: d.op },
        uHead:    { value: 0.0 },
      },
      transparent: true, depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geo, mat);
    mesh.renderOrder = 2; mesh.frustumCulled = true;
    scene.add(mesh);

    smokeWands.push({ mat, phase: i / WAND_DEFS.length, spd: d.spd });
  });
  console.log(`[K4] ✓ ${smokeWands.length} smooth wands built`);
}

// ─────────────────────────────────────────────────────────────────
// ANIMATION LOOP
// ─────────────────────────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta   = clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // ── Smoke wand animation ──────────────────────────────────────────
  // uHead travels 0→1 continuously. Speed mapped so at 40 mph the
  // comet takes ~2.2s to cross the car; at 100 mph it takes ~0.9s.
  // Each wand has a phase offset so they all look independent.
  const flowSpeed = 0.45 + ((currentSpeed - 40) / 60) * 0.67; // 0.45–1.12 full-tube/s
  for (const { mat, phase, spd } of smokeWands) {
    mat.uniforms.uHead.value = ((elapsed * flowSpeed * spd) + phase) % 1.0;
  }

  // ── WHEEL SPIN ───────────────────────────────────────────────
  // Physics: rad/s = linear_speed_m_s / wheel_radius_m
  // 40 mph = 17.88 m/s → at r=0.33m → 54.2 rad/s real
  // Visual scale factor 0.010 keeps it looking right in scene units
  // Multiply by delta (seconds since last frame) for frame-rate independence
  const wheelRadPerSec = (currentSpeed * 0.44704 / 0.33) * 0.010;
  for (const m of wheelMeshes) {
    m.rotation.x -= wheelRadPerSec * delta;
  }

  controls.update();
  renderer.render(scene, camera);  // single direct render — no composer, no artifacts
}
animate();

// ── Resize ───────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
