<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2025 Kia K4 GT-Line | Aurora Black Pearl</title>

  <!-- Three.js + addons from CDN – no installation needed -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --accent: #60b8ff;
      --accent2: #38d9ff;
      --bg: #06060f;
      --text: #e2e8f0;
      --muted: rgba(255,255,255,0.35);
    }

    html, body {
      width: 100%; height: 100%;
      background: var(--bg);
      overflow: hidden;
      font-family: 'Rajdhani', sans-serif;
    }

    /* ── Canvas ── */
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    canvas { display: block; width: 100% !important; height: 100% !important; }

    /* ── Loading screen ── */
    #loader {
      position: fixed; inset: 0;
      background: var(--bg);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 20px; z-index: 100;
      transition: opacity 0.8s ease;
    }
    #loader.hidden { opacity: 0; pointer-events: none; }

    .loader-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(13px, 2.5vw, 18px);
      letter-spacing: .35em;
      color: var(--accent);
      text-shadow: 0 0 20px #60b8ff88;
    }
    .loader-bar-wrap {
      width: 220px; height: 2px;
      background: rgba(255,255,255,0.08);
      border-radius: 2px; overflow: hidden;
    }
    .loader-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px var(--accent);
    }
    .loader-pct {
      font-family: 'Orbitron', monospace;
      font-size: 11px; letter-spacing: .2em;
      color: var(--muted);
    }

    /* ── UI Chrome ── */
    .ui-top {
      position: fixed; top: 0; left: 0; right: 0;
      padding: 24px 32px;
      display: flex; align-items: flex-start; justify-content: space-between;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(6,6,15,0.8) 0%, transparent 100%);
    }

    .brand {
      display: flex; flex-direction: column; gap: 4px;
    }
    .brand-name {
      font-family: 'Orbitron', monospace;
      font-size: clamp(14px, 2.5vw, 22px);
      font-weight: 900;
      letter-spacing: .25em;
      color: #fff;
      text-shadow: 0 0 40px rgba(96,184,255,0.3);
    }
    .brand-sub {
      font-family: 'Orbitron', monospace;
      font-size: clamp(8px, 1.2vw, 10px);
      letter-spacing: .5em;
      color: var(--accent);
      opacity: 0.8;
    }

    .ui-stats {
      display: flex; flex-direction: column; align-items: flex-end; gap: 3px;
    }
    .stat-row {
      font-family: 'Orbitron', monospace;
      font-size: 9px; letter-spacing: .15em;
      color: var(--muted);
    }
    .stat-val { color: var(--accent); }

    /* ── Speed Panel ── */
    .speed-panel {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 20px 24px 28px;
      background: linear-gradient(to top, rgba(6,6,15,0.95) 0%, transparent 100%);
      display: flex; flex-direction: column; align-items: center; gap: 12px;
    }

    .speed-label {
      font-family: 'Orbitron', monospace;
      font-size: 11px; letter-spacing: .25em;
      color: var(--muted);
      display: flex; align-items: center; gap: 10px;
    }
    .speed-mph {
      color: #fff; font-size: 20px; font-weight: 600;
      text-shadow: 0 0 16px var(--accent);
      min-width: 40px; text-align: right;
    }

    /* Preset buttons */
    .speed-presets {
      display: flex; gap: 8px;
    }
    .preset-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.5);
      border-radius: 4px;
      padding: 5px 14px;
      font-family: 'Orbitron', monospace;
      font-size: 10px; letter-spacing: .15em;
      cursor: pointer;
      transition: all .2s;
    }
    .preset-btn:hover,
    .preset-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(96,184,255,0.08);
      box-shadow: 0 0 12px rgba(96,184,255,0.15);
    }

    /* Slider */
    .speed-slider {
      width: min(280px, 80vw);
      -webkit-appearance: none;
      appearance: none;
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent), 0 0 20px rgba(96,184,255,0.4);
      cursor: pointer;
      transition: transform .15s;
    }
    .speed-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }

    /* Hint */
    .hint {
      position: fixed;
      bottom: 130px; right: 24px;
      font-family: 'Rajdhani', sans-serif;
      font-size: 11px; letter-spacing: .1em;
      color: var(--muted);
      text-align: right;
      line-height: 1.8;
      pointer-events: none;
    }

    /* Vignette */
    .vignette {
      position: fixed; inset: 0;
      background: radial-gradient(ellipse at center, transparent 45%, rgba(6,6,15,0.7) 100%);
      pointer-events: none;
    }

    /* Corner accent lines */
    .corner { position: fixed; width: 40px; height: 40px; }
    .corner-tl { top: 16px; left: 16px; border-top: 1px solid rgba(96,184,255,0.3); border-left: 1px solid rgba(96,184,255,0.3); }
    .corner-tr { top: 16px; right: 16px; border-top: 1px solid rgba(96,184,255,0.3); border-right: 1px solid rgba(96,184,255,0.3); }
    .corner-bl { bottom: 90px; left: 16px; border-bottom: 1px solid rgba(96,184,255,0.3); border-left: 1px solid rgba(96,184,255,0.3); }
    .corner-br { bottom: 90px; right: 16px; border-bottom: 1px solid rgba(96,184,255,0.3); border-right: 1px solid rgba(96,184,255,0.3); }

    @media (max-width: 480px) {
      .ui-stats { display: none; }
      .hint { display: none; }
    }
  </style>
</head>
<body>

<!-- Loading screen -->
<div id="loader">
  <div class="loader-title">LOADING K4 GT-LINE</div>
  <div class="loader-bar-wrap"><div class="loader-bar" id="loader-bar"></div></div>
  <div class="loader-pct" id="loader-pct">0%</div>
</div>

<!-- Three.js canvas -->
<div id="canvas-container"></div>

<!-- Decorative corners -->
<div class="corner corner-tl"></div>
<div class="corner corner-tr"></div>
<div class="corner corner-bl"></div>
<div class="corner corner-br"></div>

<!-- Vignette -->
<div class="vignette"></div>

<!-- Top UI -->
<div class="ui-top">
  <div class="brand">
    <div class="brand-name">KIA K4 GT-LINE</div>
    <div class="brand-sub">AURORA BLACK PEARL · 2025</div>
  </div>
  <div class="ui-stats">
    <div class="stat-row">ENGINE &nbsp;<span class="stat-val" id="stat-engine">2.0L NATURALLY ASPIRATED</span></div>
    <div class="stat-row">OUTPUT &nbsp;<span class="stat-val">147 HP · 132 LB-FT</span></div>
    <div class="stat-row">DRIVE &nbsp;<span class="stat-val">FWD · CVT</span></div>
  </div>
</div>

<!-- Drag hint -->
<div class="hint">
  DRAG TO ROTATE<br/>
  SCROLL TO ZOOM
</div>

<!-- Speed panel -->
<div class="speed-panel">
  <div class="speed-label">
    AIRFLOW SIMULATION &nbsp;·&nbsp;
    <span class="speed-mph" id="speed-display">40</span>
    &nbsp;MPH
  </div>
  <div class="speed-presets">
    <button class="preset-btn active" data-speed="40">40</button>
    <button class="preset-btn" data-speed="60">60</button>
    <button class="preset-btn" data-speed="80">80</button>
    <button class="preset-btn" data-speed="100">100</button>
  </div>
  <input type="range" class="speed-slider" id="speed-slider" min="40" max="100" step="1" value="40"/>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader }     from 'three/addons/loaders/RGBELoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';

// ─────────────────────────────────────────────
// SPEED STATE
// ─────────────────────────────────────────────
let currentSpeed = 40; // mph

const slider       = document.getElementById('speed-slider');
const speedDisplay = document.getElementById('speed-display');
const presetBtns   = document.querySelectorAll('.preset-btn');

function setSpeed(v) {
  currentSpeed = v;
  slider.value = v;
  speedDisplay.textContent = v;
  presetBtns.forEach(b => b.classList.toggle('active', +b.dataset.speed === v));
}

slider.addEventListener('input', () => setSpeed(+slider.value));
presetBtns.forEach(b => b.addEventListener('click', () => setSpeed(+b.dataset.speed)));

// ─────────────────────────────────────────────
// RENDERER
// ─────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.3;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

// ─────────────────────────────────────────────
// SCENE + CAMERA
// ─────────────────────────────────────────────
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0x06060f);
scene.fog = new THREE.FogExp2(0x06060f, 0.04);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(5, 2, 5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan     = false;
controls.minDistance   = 3;
controls.maxDistance   = 12;
controls.minPolarAngle = 0.15;
controls.maxPolarAngle = Math.PI / 2.1;
controls.autoRotate    = true;
controls.autoRotateSpeed = 0.5;
controls.enableDamping = true;
controls.dampingFactor = 0.06;

// ─────────────────────────────────────────────
// LIGHTING
// ─────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.15));

const sun = new THREE.DirectionalLight(0xffffff, 1.4);
sun.position.set(5, 8, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far  = 25;
sun.shadow.camera.left = sun.shadow.camera.bottom = -6;
sun.shadow.camera.right = sun.shadow.camera.top   =  6;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x4488ff, 0.5);
fill.position.set(-5, 3, -4);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.3);
rim.position.set(0, 2, -6);
scene.add(rim);

// ─────────────────────────────────────────────
// HDRI ENVIRONMENT  (studio-like sky for sharp reflections)
// Using a public domain HDRI from Poly Haven via CDN
// ─────────────────────────────────────────────
const rgbeLoader = new RGBELoader();
rgbeLoader.load(
  'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr',
  (hdr) => {
    hdr.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = hdr;  // used for reflections only (not background)
  },
  undefined,
  () => {
    // Fallback if network blocked – create a synthetic env map
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envScene = new THREE.RoomEnvironment();
    scene.environment = pmrem.fromScene(envScene).texture;
    pmrem.dispose();
  }
);

// ─────────────────────────────────────────────
// GROUND SHADOW PLANE
// ─────────────────────────────────────────────
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.ShadowMaterial({ opacity: 0.45 })
);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.5;
ground.receiveShadow = true;
scene.add(ground);

// Subtle reflective floor
const floorMat = new THREE.MeshStandardMaterial({
  color: 0x0a0a14,
  metalness: 0.4,
  roughness: 0.6,
  envMapIntensity: 0.5,
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y  = -0.501;
scene.add(floor);

// ─────────────────────────────────────────────
// LOAD GLB MODEL
// ─────────────────────────────────────────────
const loaderBar = document.getElementById('loader-bar');
const loaderPct = document.getElementById('loader-pct');
const loaderEl  = document.getElementById('loader');

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

// ── Material presets ──────────────────────────
const AURORA_BLACK = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x080810),
  metalness: 0.9,
  roughness: 0.08,
  envMapIntensity: 3.0,
});

const CHROME = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0xc0c8d0),
  metalness: 1.0,
  roughness: 0.04,
  envMapIntensity: 3.5,
});

const GLASS = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color(0x8ab8d8),
  metalness: 0.0,
  roughness: 0.0,
  transmission: 0.9,
  thickness: 0.4,
  transparent: true,
  opacity: 0.25,
  envMapIntensity: 1.5,
});

const RUBBER = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x111111),
  metalness: 0.0,
  roughness: 0.95,
});

function isWhitish(mat) {
  if (!mat || !mat.color) return false;
  const c = mat.color;
  return c.r > 0.72 && c.g > 0.72 && c.b > 0.72;
}

function applyMaterials(model) {
  model.traverse((node) => {
    if (!node.isMesh) return;
    node.castShadow    = true;
    node.receiveShadow = true;

    const n   = node.name.toLowerCase();
    const mat = Array.isArray(node.material) ? node.material[0] : node.material;

    const isGlassByName  = n.includes('glass') || n.includes('window') ||
                           n.includes('windshield') || n.includes('wind') ||
                           n.includes('screen') || n.includes('lens') ||
                           n.includes('light') || n.includes('lamp');
    const isGlassByColor = isWhitish(mat);

    if (isGlassByName || isGlassByColor) {
      node.material = GLASS.clone();
      node.renderOrder = 1;
    } else if (n.includes('body') || n.includes('paint') || n.includes('panel') ||
               n.includes('hood') || n.includes('door') || n.includes('fender') ||
               n.includes('roof') || n.includes('trunk') || n.includes('bumper')) {
      node.material = AURORA_BLACK.clone();
    } else if (n.includes('chrome') || n.includes('trim') || n.includes('grille') ||
               n.includes('exhaust') || n.includes('mirror')) {
      node.material = CHROME.clone();
    } else if (n.includes('tyre') || n.includes('tire') || n.includes('rubber') ||
               n.includes('wheel') || n.includes('rim')) {
      node.material = RUBBER.clone();
    }
  });
}

gltfLoader.load(
  './kiak4.glb',                  // relative to index.html
  (gltf) => {
    applyMaterials(gltf.scene);
    gltf.scene.position.y = -0.5;
    scene.add(gltf.scene);

    // Hide loader
    loaderEl.classList.add('hidden');
    setTimeout(() => loaderEl.style.display = 'none', 900);
  },
  (xhr) => {
    if (xhr.lengthComputable) {
      const pct = Math.round(xhr.loaded / xhr.total * 100);
      loaderBar.style.width = pct + '%';
      loaderPct.textContent  = pct + '%';
    }
  },
  (err) => {
    console.error('GLB load error:', err);
    loaderPct.textContent = 'MODEL NOT FOUND – place kiak4.glb next to index.html';
    loaderBar.style.background = '#f87171';
  }
);


// ═══════════════════════════════════════════════════════════════════
// OPTIMIZED SMOKE WAND SYSTEM  v4
//
// Performance changes vs v3:
//  • TubeGeometry tubularSegments: 160 → 40  (75% fewer triangles)
//  • Path control points:           80 → 24  (70% fewer curve pts)
//  • radialSegments:                10 → 6   (40% fewer tube sides)
//  • Shared ShaderMaterial pool (3 materials for 16 wands)
//    → reduces draw calls from 8 down to 3 per frame
//  • frustumCulled = true on every mesh (default, but explicit)
//  • EffectComposer renderTarget uses half-res on mobile
//  • Bloom multisampling = 0 (saves GPU fill-rate)
//
// Path changes vs v3:
//  • Global Y seed raised by +0.12 → clears front intake vents
//  • Start Z pushed to +8.5 (wider front approach)
//  • Start X widened by 15% → wands begin outside vent area
//  • Vent avoidance zone: Z=2.2–3.2, centre lanes deflect upward
//  • 16 wands spread across 4 lateral lanes + 2 height layers
// ═══════════════════════════════════════════════════════════════════

// ── 1. Bloom – half-res composer for performance ──────────────────
import { EffectComposer }  from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass }      from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass }      from 'three/addons/postprocessing/OutputPass.js';

// Half-res render target → big GPU saving, barely visible quality loss
const isMobile   = window.innerWidth < 768;
const rtScale    = isMobile ? 0.5 : 0.75;
const rtW        = Math.floor(window.innerWidth  * rtScale);
const rtH        = Math.floor(window.innerHeight * rtScale);

const composer = new EffectComposer(renderer);
composer.setPixelRatio(rtScale);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(rtW, rtH),
  0.55,   // strength
  0.40,   // radius
  0.85    // threshold – black paint stays black
);
// multisampling = 0 → no MSAA on the bloom target (saves fill-rate)
composer.renderTarget1.samples = 0;
composer.renderTarget2.samples = 0;
composer.addPass(bloomPass);
composer.addPass(new OutputPass());

// ── 2. Shared GLSL shader (written once, reused across all wands) ─
const smokeVert = `
  varying vec2 vUv;
  void main() {
    vUv         = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
  }
`;
const smokeFrag = `
  uniform vec3  uColor;
  uniform float uOpacity;
  uniform float uHead;

  varying vec2 vUv;

  void main() {
    float tailLen = 0.68;
    float behind  = uHead - vUv.x;
    if (behind < 0.0) behind += 1.0;
    if (behind > tailLen) discard;

    float along = 1.0 - (behind / tailLen);
    along      *= smoothstep(0.0, 0.03, behind + 0.001);
    float tip   = 1.0 - smoothstep(0.0, 0.05, behind);

    float radial = sin(vUv.y * 3.14159265);
    float core   = pow(radial, 2.2);

    float alpha  = along * core * uOpacity + tip * core * uOpacity * 0.6;
    if (alpha < 0.008) discard;

    vec3 col = mix(uColor, vec3(0.88, 0.97, 1.0), tip * core * 0.65);
    gl_FragColor = vec4(col, alpha);
  }
`;

// ── 3. Shared material pool ───────────────────────────────────────
// Instead of 1 material per wand (8 draw calls), we share 3 materials
// (centre / mid / outer) and only vary the uHead uniform per wand.
// Three.js batches meshes with the same material → fewer draw calls.
function makeMat(color, opacity) {
  return new THREE.ShaderMaterial({
    vertexShader:   smokeVert,
    fragmentShader: smokeFrag,
    uniforms: {
      uColor:   { value: color },
      uOpacity: { value: opacity },
      uHead:    { value: 0.0 },
    },
    transparent: true,
    depthWrite:  false,
    blending:    THREE.NormalBlending,
    side:        THREE.DoubleSide,
  });
}

// 3 shared materials for 16 wands
const matCentre = makeMat(new THREE.Color(0x38d8ff), 0.36);
const matMid    = makeMat(new THREE.Color(0x24b8e8), 0.28);
const matOuter  = makeMat(new THREE.Color(0x1898cc), 0.22);

// ── 4. Body silhouette (unchanged) ───────────────────────────────
const CLEARANCE = 0.02;

function carTopY(pz) {
  if (pz > 3.3 || pz < -3.6) return -99;
  let y;
  if      (pz >  2.5) y = -0.15 + (3.3 - pz) / 0.8  * 0.28;
  else if (pz >  0.5) y =  0.13 + (2.5 - pz) / 2.0  * 0.68;
  else if (pz > -0.5) y =  0.81 + Math.sin((pz + 0.5) / 1.0 * Math.PI) * 0.05;
  else if (pz > -3.1) y =  0.81 - (-0.5 - pz) / 2.6  * 0.83;
  else                y = -0.02;
  return y + CLEARANCE;
}

// ── 5. Optimized path builder ─────────────────────────────────────
//
// KEY FIXES vs v3:
//  a) seedY raised by +0.12 globally → clears intake vents on the
//     front bumper which sit at roughly Y=0.0–0.10
//  b) Vent avoidance zone (Z=2.0–3.3): centre-lane wands are pushed
//     an extra +0.15 upward so they arc OVER the grille/vents
//  c) Start Z = +8.5 (was +7) and start X spread ×1.15 so wands
//     approach from further out, framing the car like a wind tunnel
//  d) nPts reduced from 80 → 24 for the path skeleton;
//     CatmullRomCurve3 smooths it, TubeGeometry subdivides further
//
function buildWandPath(seedX, seedY, nPts = 24) {
  // a) Global vent-clearance lift
  const liftedY = seedY + 0.12;

  const pts = [];
  for (let i = 0; i < nPts; i++) {
    const t  = i / (nPts - 1);
    const pz = 8.5 - t * 14.5;   // +8.5 (far front) → -6.0 (wake)

    let x = seedX;
    let y = liftedY;

    const top   = carTopY(pz);
    const onCar = top > -90 && Math.abs(seedX) < 0.96;

    // b) Vent avoidance: extra upward push in the front grille zone
    const inVentZone = pz > 2.0 && pz < 3.3 && Math.abs(seedX) < 0.55;
    const ventLift   = inVentZone
      ? 0.15 * Math.sin((pz - 2.0) / 1.3 * Math.PI)
      : 0.0;

    if (onCar && y < top + ventLift) {
      y = top + ventLift;
    }

    // Wheel arch splay
    if (Math.abs(seedX) > 0.55 && pz > -3.2 && pz < 3.2) {
      const arch = 0.09 * Math.max(0, Math.sin((3.2 - Math.abs(pz)) / 3.2 * Math.PI));
      x = seedX > 0 ? seedX + arch : seedX - arch;
    }

    // Wake recovery
    if (pz < -3.3) {
      const wt = Math.min((-3.3 - pz) / 3.0, 1.0);
      y += (liftedY - y) * wt * 0.4;
    }

    pts.push(new THREE.Vector3(x, y, pz));
  }
  return pts;
}

// ── 6. 16 wand definitions ────────────────────────────────────────
//
// Layout: 4 lateral lanes × 2 height layers + 2 underbody + 2 high
// Each wand has its own speedMult so flow looks organic not robotic.
//
// Lane positions (x): ±0.00, ±0.28, ±0.58, ±0.82
// Height layers (y):  low (0.06–0.10), high (0.20–0.26)
//
const wandDefs = [
  // ── Centre lane ──────────────────────────────────────────────────
  { x:  0.00, y: 0.06, r: 0.022, mat: matCentre, spd: 0.88 },
  { x:  0.00, y: 0.22, r: 0.016, mat: matMid,    spd: 0.76 },

  // ── Inner lanes (±0.28 – just inside A-pillars) ──────────────────
  { x: -0.28, y: 0.07, r: 0.018, mat: matCentre, spd: 0.95 },
  { x:  0.28, y: 0.07, r: 0.018, mat: matCentre, spd: 0.82 },
  { x: -0.28, y: 0.24, r: 0.014, mat: matMid,    spd: 1.05 },
  { x:  0.28, y: 0.24, r: 0.014, mat: matMid,    spd: 0.70 },

  // ── Mid lanes (±0.58 – over door / mirror) ───────────────────────
  { x: -0.58, y: 0.10, r: 0.015, mat: matMid,    spd: 0.92 },
  { x:  0.58, y: 0.10, r: 0.015, mat: matMid,    spd: 1.08 },
  { x: -0.58, y: 0.26, r: 0.012, mat: matOuter,  spd: 0.78 },
  { x:  0.58, y: 0.26, r: 0.012, mat: matOuter,  spd: 0.85 },

  // ── Outer lanes (±0.82 – fender / wheel arch) ────────────────────
  { x: -0.82, y: 0.18, r: 0.011, mat: matOuter,  spd: 1.12 },
  { x:  0.82, y: 0.18, r: 0.011, mat: matOuter,  spd: 0.68 },

  // ── High free-stream (above roof) ────────────────────────────────
  { x: -0.20, y: 1.08, r: 0.010, mat: matOuter,  spd: 0.98 },
  { x:  0.20, y: 1.08, r: 0.010, mat: matOuter,  spd: 0.88 },

  // ── Underbody / sill ─────────────────────────────────────────────
  { x: -0.48, y:-0.28, r: 0.010, mat: matOuter,  spd: 1.02 },
  { x:  0.48, y:-0.28, r: 0.010, mat: matOuter,  spd: 0.75 },
];

// ── 7. Build meshes ───────────────────────────────────────────────
//
// Geometry: 40 tubular segments (was 160) × 6 radial (was 10)
// = 480 quads per wand vs 3200 previously → 85% fewer triangles
//
const smokeWands = wandDefs.map((def, i) => {
  const pts   = buildWandPath(def.x, def.y, 24);
  const curve = new THREE.CatmullRomCurve3(pts);

  // Low-poly tube: CatmullRom + shader do the visual smoothing
  const geo   = new THREE.TubeGeometry(curve, 40, def.r, 6, false);

  // Each wand gets its OWN uniform object cloned from the shared mat
  // so uHead can be animated independently per wand.
  const mat = def.mat.clone();
  mat.uniforms = {
    uColor:   { value: def.mat.uniforms.uColor.value },
    uOpacity: { value: def.mat.uniforms.uOpacity.value },
    uHead:    { value: 0.0 },
  };

  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder    = 2;
  mesh.frustumCulled  = true;   // ← stops GPU work when off-screen

  // Pre-compute bounding sphere so Three.js frustum test is accurate
  geo.computeBoundingSphere();

  scene.add(mesh);

  return {
    mat,
    phaseOffset: i / wandDefs.length,
    speedMult:   def.spd,
  };
});

// ── 8. Animation loop ─────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // 40 mph = 0.26/s head travel,  100 mph = 0.85/s
  const baseSpeed = 0.26 + ((currentSpeed - 40) / 60) * 0.59;

  for (let i = 0; i < smokeWands.length; i++) {
    const { mat, phaseOffset, speedMult } = smokeWands[i];
    mat.uniforms.uHead.value =
      ((elapsed * baseSpeed * speedMult) + phaseOffset) % 1.0;
  }

  controls.update();
  composer.render();
}
animate();

// ── 9. Resize ─────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  bloomPass.setSize(
    Math.floor(window.innerWidth  * rtScale),
    Math.floor(window.innerHeight * rtScale)
  );
});
</script>
</body>
</html>
